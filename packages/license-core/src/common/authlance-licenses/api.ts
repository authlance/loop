/* tslint:disable */
/* eslint-disable */
/**
 * License Operator API
 * License issuance, Stripe webhook processing, and product metadata for Authlance.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgDomainPricingTier
 */
export interface GithubComAuthlanceLicenseoperatorPkgDomainPricingTier {
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgDomainPricingTier
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgDomainPricingTier
     */
    'factor'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComAuthlanceLicenseoperatorPkgDomainPricingTier
     */
    'perUnit'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgDomainPricingTier
     */
    'upperBound'?: number;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsChargeSummary
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsChargeSummary {
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsChargeSummary
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsChargeSummary
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsChargeSummary
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsChargeSummary
     */
    'paid'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsChargeSummary
     */
    'paymentMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsChargeSummary
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCheckoutSessionRequest
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCheckoutSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCheckoutSessionRequest
     */
    'cookieDomain'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCheckoutSessionRequest
     */
    'couponCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCheckoutSessionRequest
     */
    'lookupKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCheckoutSessionRequest
     */
    'managedProducts'?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCheckoutSessionRequest
     */
    'organizationLongName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCheckoutSessionRequest
     */
    'organizationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCheckoutSessionRequest
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCustomerPortalSessionRequest
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCustomerPortalSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCustomerPortalSessionRequest
     */
    'customerId'?: string;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCustomerPortalSessionResponse
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCustomerPortalSessionResponse {
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCustomerPortalSessionResponse
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsGetProductDetailsRequest
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsGetProductDetailsRequest {
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsGetProductDetailsRequest
     */
    'lookup_key'?: string;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsGetProductDetailsResponse
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsGetProductDetailsResponse {
    /**
     * 
     * @type {GithubComAuthlanceLicenseoperatorPkgPaymentsStripeProductDetails}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsGetProductDetailsResponse
     */
    'product'?: GithubComAuthlanceLicenseoperatorPkgPaymentsStripeProductDetails;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsGetSubscriptionSessionRequest
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsGetSubscriptionSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsGetSubscriptionSessionRequest
     */
    'sessionId'?: string;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsGetSubscriptionSessionResponse
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsGetSubscriptionSessionResponse {
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsGetSubscriptionSessionResponse
     */
    'subscriptionId'?: string;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsInvoiceSummary
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsInvoiceSummary {
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsInvoiceSummary
     */
    'amountSubtotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsInvoiceSummary
     */
    'amountTax'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsInvoiceSummary
     */
    'amountTotal'?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsInvoiceSummary
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsInvoiceSummary
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsInvoiceSummary
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsInvoiceSummary
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsInvoiceSummary
     */
    'paidAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsInvoiceSummary
     */
    'priceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsInvoiceSummary
     */
    'priceLookupKey'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsInvoiceSummary
     */
    'priceMetadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsInvoiceSummary
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsLicenseVerificationSummary
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsLicenseVerificationSummary {
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsLicenseVerificationSummary
     */
    'couponCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsLicenseVerificationSummary
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsLicenseVerificationSummary
     */
    'domain'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsLicenseVerificationSummary
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsLicenseVerificationSummary
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsLicenseVerificationSummary
     */
    'licenseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsLicenseVerificationSummary
     */
    'plan'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsLicenseVerificationSummary
     */
    'priceLocked'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsLicenseVerificationSummary
     */
    'seats'?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsLicenseVerificationSummary
     */
    'stripeCheckoutId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsLicenseVerificationSummary
     */
    'stripeCustomerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsLicenseVerificationSummary
     */
    'stripeInvoiceId'?: string;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentBillingAddress
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentBillingAddress {
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentBillingAddress
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentBillingAddress
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentBillingAddress
     */
    'line1'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentBillingAddress
     */
    'line2'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentBillingAddress
     */
    'postalCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentBillingAddress
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentIntentSummary
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentIntentSummary {
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentIntentSummary
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentIntentSummary
     */
    'amountReceived'?: number;
    /**
     * 
     * @type {Array<GithubComAuthlanceLicenseoperatorPkgPaymentsChargeSummary>}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentIntentSummary
     */
    'charges'?: Array<GithubComAuthlanceLicenseoperatorPkgPaymentsChargeSummary>;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentIntentSummary
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentIntentSummary
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentIntentSummary
     */
    'id'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentIntentSummary
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentIntentSummary
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord {
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord
     */
    'amountSubtotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord
     */
    'amountTax'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord
     */
    'amountTotal'?: number;
    /**
     * 
     * @type {GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentBillingAddress}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord
     */
    'billingAddress'?: GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentBillingAddress;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord
     */
    'capturedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord
     */
    'customerEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord
     */
    'customerFirstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord
     */
    'customerLastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord
     */
    'invoiceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord
     */
    'organizationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord
     */
    'paidAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord
     */
    'paymentIntentId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord
     */
    'productId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord
     */
    'stripeCustomerId'?: string;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentVerificationResponse
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentVerificationResponse {
    /**
     * 
     * @type {GithubComAuthlanceLicenseoperatorPkgPaymentsInvoiceSummary}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentVerificationResponse
     */
    'invoice'?: GithubComAuthlanceLicenseoperatorPkgPaymentsInvoiceSummary;
    /**
     * 
     * @type {GithubComAuthlanceLicenseoperatorPkgPaymentsLicenseVerificationSummary}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentVerificationResponse
     */
    'license'?: GithubComAuthlanceLicenseoperatorPkgPaymentsLicenseVerificationSummary;
    /**
     * 
     * @type {GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentIntentSummary}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentVerificationResponse
     */
    'paymentIntent'?: GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentIntentSummary;
    /**
     * 
     * @type {GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentVerificationResponse
     */
    'product'?: GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary;
    /**
     * 
     * @type {GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentVerificationResponse
     */
    'recordedPayment'?: GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentsPage
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentsPage {
    /**
     * 
     * @type {Array<GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord>}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentsPage
     */
    'items'?: Array<GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentRecord>;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentsPage
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentsPage
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentsPage
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary {
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary
     */
    'baseAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary
     */
    'billingInterval'?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary
     */
    'billingIntervalCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary
     */
    'lookupKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary
     */
    'maxManagedProducts'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary
     */
    'plan'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary
     */
    'pricingMode'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary
     */
    'stripePriceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary
     */
    'stripeProductId'?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary
     */
    'trialPeriodDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsProductVerificationSummary
     */
    'unitAmount'?: number;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsStripeCheckoutSessionResponse
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsStripeCheckoutSessionResponse {
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsStripeCheckoutSessionResponse
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsStripeCheckoutSessionResponse
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsStripeProductDetails
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsStripeProductDetails {
    /**
     * 
     * @type {boolean}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsStripeProductDetails
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsStripeProductDetails
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsStripeProductDetails
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsStripeProductDetails
     */
    'lookup_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsStripeProductDetails
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsStripeProductDetails
     */
    'object'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsStripeProductDetails
     */
    'product'?: { [key: string]: any; };
    /**
     * 
     * @type {GithubComAuthlanceLicenseoperatorPkgPaymentsStripeRecurring}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsStripeProductDetails
     */
    'recurring'?: GithubComAuthlanceLicenseoperatorPkgPaymentsStripeRecurring;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsStripeProductDetails
     */
    'tax_behavior'?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsStripeProductDetails
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsStripeProductDetails
     */
    'unit_amount'?: number;
}
/**
 * 
 * @export
 * @interface GithubComAuthlanceLicenseoperatorPkgPaymentsStripeRecurring
 */
export interface GithubComAuthlanceLicenseoperatorPkgPaymentsStripeRecurring {
    /**
     * 
     * @type {string}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsStripeRecurring
     */
    'interval'?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComAuthlanceLicenseoperatorPkgPaymentsStripeRecurring
     */
    'interval_count'?: number;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerBundleComponentRequest
 */
export interface InternalHttpControllerBundleComponentRequest {
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerBundleComponentRequest
     */
    'managedProducts'?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerBundleComponentRequest
     */
    'productKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerBundleComponentRequest
     */
    'quantity'?: number;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerBundledProductResponse
 */
export interface InternalHttpControllerBundledProductResponse {
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerBundledProductResponse
     */
    'managedProducts'?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerBundledProductResponse
     */
    'plan'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerBundledProductResponse
     */
    'pricingMode'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerBundledProductResponse
     */
    'productKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerBundledProductResponse
     */
    'productSlug'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerBundledProductResponse
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerBundledProductResponse
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerCouponListResponse
 */
export interface InternalHttpControllerCouponListResponse {
    /**
     * 
     * @type {Array<InternalHttpControllerCouponResponse>}
     * @memberof InternalHttpControllerCouponListResponse
     */
    'items'?: Array<InternalHttpControllerCouponResponse>;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerCouponListResponse
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerCouponListResponse
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerCouponListResponse
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerCouponRequest
 */
export interface InternalHttpControllerCouponRequest {
    /**
     * 
     * @type {boolean}
     * @memberof InternalHttpControllerCouponRequest
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerCouponRequest
     */
    'behavior'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerCouponRequest
     */
    'code'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerCouponRequest
     */
    'maxManagedProducts'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerCouponRequest
     */
    'maxPerGroup'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerCouponRequest
     */
    'maxTotal'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InternalHttpControllerCouponRequest
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerCouponRequest
     */
    'minManagedProducts'?: number;
    /**
     * 
     * @type {InternalHttpControllerStripePromotionPayload}
     * @memberof InternalHttpControllerCouponRequest
     */
    'stripePromotion'?: InternalHttpControllerStripePromotionPayload;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerCouponResponse
 */
export interface InternalHttpControllerCouponResponse {
    /**
     * 
     * @type {boolean}
     * @memberof InternalHttpControllerCouponResponse
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerCouponResponse
     */
    'behavior'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerCouponResponse
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerCouponResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerCouponResponse
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerCouponResponse
     */
    'maxManagedProducts'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerCouponResponse
     */
    'maxPerGroup'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerCouponResponse
     */
    'maxTotal'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InternalHttpControllerCouponResponse
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerCouponResponse
     */
    'minManagedProducts'?: number;
    /**
     * 
     * @type {InternalHttpControllerStripePromotionPayload}
     * @memberof InternalHttpControllerCouponResponse
     */
    'stripePromotion'?: InternalHttpControllerStripePromotionPayload;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerCouponResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerIssueLicenseRequest
 */
export interface InternalHttpControllerIssueLicenseRequest {
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerIssueLicenseRequest
     */
    'domain'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerIssueLicenseRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerIssueLicenseRequest
     */
    'exp'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerIssueLicenseRequest
     */
    'group'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerIssueLicenseRequest
     */
    'managedProducts'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InternalHttpControllerIssueLicenseRequest
     */
    'persist'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerIssueLicenseRequest
     */
    'plan'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InternalHttpControllerIssueLicenseRequest
     */
    'priceLocked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerIssueLicenseRequest
     */
    'productKey'?: string;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerLicenseListItem
 */
export interface InternalHttpControllerLicenseListItem {
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerLicenseListItem
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerLicenseListItem
     */
    'domain'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerLicenseListItem
     */
    'exp'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerLicenseListItem
     */
    'groupName'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerLicenseListItem
     */
    'licenseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerLicenseListItem
     */
    'plan'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InternalHttpControllerLicenseListItem
     */
    'priceLocked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerLicenseListItem
     */
    'productKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerLicenseListItem
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerPaginatedLicenseList
 */
export interface InternalHttpControllerPaginatedLicenseList {
    /**
     * 
     * @type {Array<InternalHttpControllerLicenseListItem>}
     * @memberof InternalHttpControllerPaginatedLicenseList
     */
    'items'?: Array<InternalHttpControllerLicenseListItem>;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerPaginatedLicenseList
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerPaginatedLicenseList
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerPaginatedLicenseList
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerPricingTierRequest
 */
export interface InternalHttpControllerPricingTierRequest {
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerPricingTierRequest
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerPricingTierRequest
     */
    'factor'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InternalHttpControllerPricingTierRequest
     */
    'perUnit'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerPricingTierRequest
     */
    'upperBound'?: number;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerProductDetailsResponse
 */
export interface InternalHttpControllerProductDetailsResponse {
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductDetailsResponse
     */
    'baseAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductDetailsResponse
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductDetailsResponse
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InternalHttpControllerProductDetailsResponse
     */
    'features'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductDetailsResponse
     */
    'interval'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductDetailsResponse
     */
    'lookupKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductDetailsResponse
     */
    'maxManagedProducts'?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductDetailsResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductDetailsResponse
     */
    'priceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductDetailsResponse
     */
    'pricingMode'?: string;
    /**
     * 
     * @type {Array<GithubComAuthlanceLicenseoperatorPkgDomainPricingTier>}
     * @memberof InternalHttpControllerProductDetailsResponse
     */
    'pricingTiers'?: Array<GithubComAuthlanceLicenseoperatorPkgDomainPricingTier>;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductDetailsResponse
     */
    'productId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductDetailsResponse
     */
    'productKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductDetailsResponse
     */
    'publicBaseUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductDetailsResponse
     */
    'unitAmount'?: number;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerProductKeyItem
 */
export interface InternalHttpControllerProductKeyItem {
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductKeyItem
     */
    'priceMode'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductKeyItem
     */
    'productKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductKeyItem
     */
    'productType'?: string;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerProductKeyListResponse
 */
export interface InternalHttpControllerProductKeyListResponse {
    /**
     * 
     * @type {Array<InternalHttpControllerProductKeyItem>}
     * @memberof InternalHttpControllerProductKeyListResponse
     */
    'keys'?: Array<InternalHttpControllerProductKeyItem>;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerProductListResponse
 */
export interface InternalHttpControllerProductListResponse {
    /**
     * 
     * @type {Array<InternalHttpControllerProductResponse>}
     * @memberof InternalHttpControllerProductListResponse
     */
    'items'?: Array<InternalHttpControllerProductResponse>;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductListResponse
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductListResponse
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductListResponse
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerProductRequest
 */
export interface InternalHttpControllerProductRequest {
    /**
     * 
     * @type {boolean}
     * @memberof InternalHttpControllerProductRequest
     */
    'active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductRequest
     */
    'baseAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductRequest
     */
    'billingInterval'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductRequest
     */
    'billingIntervalCount'?: number;
    /**
     * 
     * @type {Array<InternalHttpControllerBundleComponentRequest>}
     * @memberof InternalHttpControllerProductRequest
     */
    'bundledProducts'?: Array<InternalHttpControllerBundleComponentRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof InternalHttpControllerProductRequest
     */
    'configManaged'?: boolean;
    /**
     * 
     * @type {Array<InternalHttpControllerCouponRequest>}
     * @memberof InternalHttpControllerProductRequest
     */
    'coupons'?: Array<InternalHttpControllerCouponRequest>;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductRequest
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductRequest
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InternalHttpControllerProductRequest
     */
    'internal'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductRequest
     */
    'lookupKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductRequest
     */
    'maxLicenseTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductRequest
     */
    'maxManagedProducts'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InternalHttpControllerProductRequest
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductRequest
     */
    'plan'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductRequest
     */
    'pricingMode'?: string;
    /**
     * 
     * @type {Array<InternalHttpControllerPricingTierRequest>}
     * @memberof InternalHttpControllerProductRequest
     */
    'pricingTiers'?: Array<InternalHttpControllerPricingTierRequest>;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductRequest
     */
    'productKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductRequest
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductRequest
     */
    'stripePriceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductRequest
     */
    'stripeProductId'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductRequest
     */
    'termDurationDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductRequest
     */
    'trialPeriodDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductRequest
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductRequest
     */
    'unitAmount'?: number;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerProductResponse
 */
export interface InternalHttpControllerProductResponse {
    /**
     * 
     * @type {boolean}
     * @memberof InternalHttpControllerProductResponse
     */
    'active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductResponse
     */
    'baseAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductResponse
     */
    'billingInterval'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductResponse
     */
    'billingIntervalCount'?: number;
    /**
     * 
     * @type {Array<InternalHttpControllerBundledProductResponse>}
     * @memberof InternalHttpControllerProductResponse
     */
    'bundledProducts'?: Array<InternalHttpControllerBundledProductResponse>;
    /**
     * 
     * @type {boolean}
     * @memberof InternalHttpControllerProductResponse
     */
    'configManaged'?: boolean;
    /**
     * 
     * @type {Array<InternalHttpControllerCouponResponse>}
     * @memberof InternalHttpControllerProductResponse
     */
    'coupons'?: Array<InternalHttpControllerCouponResponse>;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductResponse
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductResponse
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InternalHttpControllerProductResponse
     */
    'internal'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductResponse
     */
    'lookupKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductResponse
     */
    'maxLicenseTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductResponse
     */
    'maxManagedProducts'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InternalHttpControllerProductResponse
     */
    'metadata'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductResponse
     */
    'plan'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductResponse
     */
    'pricingMode'?: string;
    /**
     * 
     * @type {Array<GithubComAuthlanceLicenseoperatorPkgDomainPricingTier>}
     * @memberof InternalHttpControllerProductResponse
     */
    'pricingTiers'?: Array<GithubComAuthlanceLicenseoperatorPkgDomainPricingTier>;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductResponse
     */
    'productKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductResponse
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductResponse
     */
    'stripePriceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductResponse
     */
    'stripeProductId'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductResponse
     */
    'termDurationDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductResponse
     */
    'trialPeriodDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductResponse
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerProductResponse
     */
    'unitAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerProductResponse
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerPublicBundledProductResponse
 */
export interface InternalHttpControllerPublicBundledProductResponse {
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerPublicBundledProductResponse
     */
    'managedProducts'?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerPublicBundledProductResponse
     */
    'plan'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerPublicBundledProductResponse
     */
    'pricingMode'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerPublicBundledProductResponse
     */
    'productKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerPublicBundledProductResponse
     */
    'productSlug'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerPublicBundledProductResponse
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerPublicBundledProductResponse
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerPublicCouponResponse
 */
export interface InternalHttpControllerPublicCouponResponse {
    /**
     * 
     * @type {boolean}
     * @memberof InternalHttpControllerPublicCouponResponse
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerPublicCouponResponse
     */
    'code'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerPublicCouponResponse
     */
    'maxPerGroup'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerPublicCouponResponse
     */
    'maxTotal'?: number;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerPublicProductResponse
 */
export interface InternalHttpControllerPublicProductResponse {
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerPublicProductResponse
     */
    'baseAmount'?: number;
    /**
     * 
     * @type {Array<InternalHttpControllerPublicBundledProductResponse>}
     * @memberof InternalHttpControllerPublicProductResponse
     */
    'bundledProducts'?: Array<InternalHttpControllerPublicBundledProductResponse>;
    /**
     * 
     * @type {Array<InternalHttpControllerPublicCouponResponse>}
     * @memberof InternalHttpControllerPublicProductResponse
     */
    'coupons'?: Array<InternalHttpControllerPublicCouponResponse>;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerPublicProductResponse
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerPublicProductResponse
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InternalHttpControllerPublicProductResponse
     */
    'features'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerPublicProductResponse
     */
    'interval'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerPublicProductResponse
     */
    'lookupKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerPublicProductResponse
     */
    'maxManagedProducts'?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerPublicProductResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerPublicProductResponse
     */
    'plan'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerPublicProductResponse
     */
    'pricingMode'?: string;
    /**
     * 
     * @type {Array<GithubComAuthlanceLicenseoperatorPkgDomainPricingTier>}
     * @memberof InternalHttpControllerPublicProductResponse
     */
    'pricingTiers'?: Array<GithubComAuthlanceLicenseoperatorPkgDomainPricingTier>;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerPublicProductResponse
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerPublicProductResponse
     */
    'stripePriceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerPublicProductResponse
     */
    'stripeProductId'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerPublicProductResponse
     */
    'unitAmount'?: number;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerSeatLimitErrorResponse
 */
export interface InternalHttpControllerSeatLimitErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerSeatLimitErrorResponse
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerSeatLimitErrorResponse
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerSeatLimitErrorResponse
     */
    'required'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerSeatLimitErrorResponse
     */
    'seatLimit'?: number;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerSeatUsageResponse
 */
export interface InternalHttpControllerSeatUsageResponse {
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerSeatUsageResponse
     */
    'activeConfigManaged'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerSeatUsageResponse
     */
    'activeCustom'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerSeatUsageResponse
     */
    'activeTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerSeatUsageResponse
     */
    'availableSeats'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerSeatUsageResponse
     */
    'seatLimit'?: number;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerStripePromotionPayload
 */
export interface InternalHttpControllerStripePromotionPayload {
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerStripePromotionPayload
     */
    'amountOff'?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerStripePromotionPayload
     */
    'couponId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerStripePromotionPayload
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerStripePromotionPayload
     */
    'duration'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerStripePromotionPayload
     */
    'durationInMonths'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerStripePromotionPayload
     */
    'maxRedemptions'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalHttpControllerStripePromotionPayload
     */
    'percentOff'?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerStripePromotionPayload
     */
    'promotionId'?: string;
}
/**
 * 
 * @export
 * @interface InternalHttpControllerTrialIssueRequest
 */
export interface InternalHttpControllerTrialIssueRequest {
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerTrialIssueRequest
     */
    'domain'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerTrialIssueRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalHttpControllerTrialIssueRequest
     */
    'productKey'?: string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns configured products with coupon metadata.
         * @summary List products
         * @param {boolean} [includeInactive] Include inactive products
         * @param {boolean} [includeInternal] Include internal products (sysadmin only)
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Page size (default 20, max 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseAdminProductsGet: async (includeInactive?: boolean, includeInternal?: boolean, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/license/admin/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeInactive !== undefined) {
                localVarQueryParameter['includeInactive'] = includeInactive;
            }

            if (includeInternal !== undefined) {
                localVarQueryParameter['includeInternal'] = includeInternal;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a product and optionally creates coupons.
         * @summary Create product
         * @param {InternalHttpControllerProductRequest} payload Product definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseAdminProductsPost: async (payload: InternalHttpControllerProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceLicenseAdminProductsPost', 'payload', payload)
            const localVarPath = `/authlance/license/admin/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current product seat utilization and remaining capacity.
         * @summary Get seat usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseAdminProductsSeatUsageGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/license/admin/products/seat-usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the specified coupon from the product.
         * @summary Delete coupon
         * @param {string} slug Product slug
         * @param {number} couponId Coupon identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseAdminProductsSlugCouponsCouponIdDelete: async (slug: string, couponId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('authlanceLicenseAdminProductsSlugCouponsCouponIdDelete', 'slug', slug)
            // verify required parameter 'couponId' is not null or undefined
            assertParamExists('authlanceLicenseAdminProductsSlugCouponsCouponIdDelete', 'couponId', couponId)
            const localVarPath = `/authlance/license/admin/products/{slug}/coupons/{couponId}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)))
                .replace(`{${"couponId"}}`, encodeURIComponent(String(couponId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies coupon metadata for the given product.
         * @summary Update coupon
         * @param {string} slug Product slug
         * @param {number} couponId Coupon identifier
         * @param {InternalHttpControllerCouponRequest} payload Coupon definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseAdminProductsSlugCouponsCouponIdPut: async (slug: string, couponId: number, payload: InternalHttpControllerCouponRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('authlanceLicenseAdminProductsSlugCouponsCouponIdPut', 'slug', slug)
            // verify required parameter 'couponId' is not null or undefined
            assertParamExists('authlanceLicenseAdminProductsSlugCouponsCouponIdPut', 'couponId', couponId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceLicenseAdminProductsSlugCouponsCouponIdPut', 'payload', payload)
            const localVarPath = `/authlance/license/admin/products/{slug}/coupons/{couponId}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)))
                .replace(`{${"couponId"}}`, encodeURIComponent(String(couponId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists coupons configured for the specified product.
         * @summary List coupons
         * @param {string} slug Product slug
         * @param {boolean} [includeInactive] Include inactive coupons
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Page size (default 20, max 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseAdminProductsSlugCouponsGet: async (slug: string, includeInactive?: boolean, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('authlanceLicenseAdminProductsSlugCouponsGet', 'slug', slug)
            const localVarPath = `/authlance/license/admin/products/{slug}/coupons`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (includeInactive !== undefined) {
                localVarQueryParameter['includeInactive'] = includeInactive;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a coupon to the specified product.
         * @summary Create coupon
         * @param {string} slug Product slug
         * @param {InternalHttpControllerCouponRequest} payload Coupon definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseAdminProductsSlugCouponsPost: async (slug: string, payload: InternalHttpControllerCouponRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('authlanceLicenseAdminProductsSlugCouponsPost', 'slug', slug)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceLicenseAdminProductsSlugCouponsPost', 'payload', payload)
            const localVarPath = `/authlance/license/admin/products/{slug}/coupons`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies a product and optionally registers additional coupons.
         * @summary Update product
         * @param {string} slug Product slug
         * @param {InternalHttpControllerProductRequest} payload Product definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseAdminProductsSlugPut: async (slug: string, payload: InternalHttpControllerProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('authlanceLicenseAdminProductsSlugPut', 'slug', slug)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceLicenseAdminProductsSlugPut', 'payload', payload)
            const localVarPath = `/authlance/license/admin/products/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the set of configured security product keys that can be associated with products.
         * @summary List product keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseProductKeysGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/license/product-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns configured products with coupon metadata.
         * @summary List products
         * @param {boolean} [includeInactive] Include inactive products
         * @param {boolean} [includeInternal] Include internal products (sysadmin only)
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Page size (default 20, max 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseAdminProductsGet(includeInactive?: boolean, includeInternal?: boolean, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHttpControllerProductListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseAdminProductsGet(includeInactive, includeInternal, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.authlanceLicenseAdminProductsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Registers a product and optionally creates coupons.
         * @summary Create product
         * @param {InternalHttpControllerProductRequest} payload Product definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseAdminProductsPost(payload: InternalHttpControllerProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHttpControllerProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseAdminProductsPost(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.authlanceLicenseAdminProductsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the current product seat utilization and remaining capacity.
         * @summary Get seat usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseAdminProductsSeatUsageGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHttpControllerSeatUsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseAdminProductsSeatUsageGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.authlanceLicenseAdminProductsSeatUsageGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the specified coupon from the product.
         * @summary Delete coupon
         * @param {string} slug Product slug
         * @param {number} couponId Coupon identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseAdminProductsSlugCouponsCouponIdDelete(slug: string, couponId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseAdminProductsSlugCouponsCouponIdDelete(slug, couponId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.authlanceLicenseAdminProductsSlugCouponsCouponIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modifies coupon metadata for the given product.
         * @summary Update coupon
         * @param {string} slug Product slug
         * @param {number} couponId Coupon identifier
         * @param {InternalHttpControllerCouponRequest} payload Coupon definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseAdminProductsSlugCouponsCouponIdPut(slug: string, couponId: number, payload: InternalHttpControllerCouponRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHttpControllerCouponResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseAdminProductsSlugCouponsCouponIdPut(slug, couponId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.authlanceLicenseAdminProductsSlugCouponsCouponIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists coupons configured for the specified product.
         * @summary List coupons
         * @param {string} slug Product slug
         * @param {boolean} [includeInactive] Include inactive coupons
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Page size (default 20, max 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseAdminProductsSlugCouponsGet(slug: string, includeInactive?: boolean, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHttpControllerCouponListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseAdminProductsSlugCouponsGet(slug, includeInactive, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.authlanceLicenseAdminProductsSlugCouponsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds a coupon to the specified product.
         * @summary Create coupon
         * @param {string} slug Product slug
         * @param {InternalHttpControllerCouponRequest} payload Coupon definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseAdminProductsSlugCouponsPost(slug: string, payload: InternalHttpControllerCouponRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHttpControllerCouponResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseAdminProductsSlugCouponsPost(slug, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.authlanceLicenseAdminProductsSlugCouponsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modifies a product and optionally registers additional coupons.
         * @summary Update product
         * @param {string} slug Product slug
         * @param {InternalHttpControllerProductRequest} payload Product definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseAdminProductsSlugPut(slug: string, payload: InternalHttpControllerProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHttpControllerProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseAdminProductsSlugPut(slug, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.authlanceLicenseAdminProductsSlugPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the set of configured security product keys that can be associated with products.
         * @summary List product keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseProductKeysGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHttpControllerProductKeyListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseProductKeysGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.authlanceLicenseProductKeysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Returns configured products with coupon metadata.
         * @summary List products
         * @param {boolean} [includeInactive] Include inactive products
         * @param {boolean} [includeInternal] Include internal products (sysadmin only)
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Page size (default 20, max 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseAdminProductsGet(includeInactive?: boolean, includeInternal?: boolean, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<InternalHttpControllerProductListResponse> {
            return localVarFp.authlanceLicenseAdminProductsGet(includeInactive, includeInternal, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a product and optionally creates coupons.
         * @summary Create product
         * @param {InternalHttpControllerProductRequest} payload Product definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseAdminProductsPost(payload: InternalHttpControllerProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHttpControllerProductResponse> {
            return localVarFp.authlanceLicenseAdminProductsPost(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current product seat utilization and remaining capacity.
         * @summary Get seat usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseAdminProductsSeatUsageGet(options?: RawAxiosRequestConfig): AxiosPromise<InternalHttpControllerSeatUsageResponse> {
            return localVarFp.authlanceLicenseAdminProductsSeatUsageGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the specified coupon from the product.
         * @summary Delete coupon
         * @param {string} slug Product slug
         * @param {number} couponId Coupon identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseAdminProductsSlugCouponsCouponIdDelete(slug: string, couponId: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.authlanceLicenseAdminProductsSlugCouponsCouponIdDelete(slug, couponId, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifies coupon metadata for the given product.
         * @summary Update coupon
         * @param {string} slug Product slug
         * @param {number} couponId Coupon identifier
         * @param {InternalHttpControllerCouponRequest} payload Coupon definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseAdminProductsSlugCouponsCouponIdPut(slug: string, couponId: number, payload: InternalHttpControllerCouponRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHttpControllerCouponResponse> {
            return localVarFp.authlanceLicenseAdminProductsSlugCouponsCouponIdPut(slug, couponId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists coupons configured for the specified product.
         * @summary List coupons
         * @param {string} slug Product slug
         * @param {boolean} [includeInactive] Include inactive coupons
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Page size (default 20, max 100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseAdminProductsSlugCouponsGet(slug: string, includeInactive?: boolean, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<InternalHttpControllerCouponListResponse> {
            return localVarFp.authlanceLicenseAdminProductsSlugCouponsGet(slug, includeInactive, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a coupon to the specified product.
         * @summary Create coupon
         * @param {string} slug Product slug
         * @param {InternalHttpControllerCouponRequest} payload Coupon definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseAdminProductsSlugCouponsPost(slug: string, payload: InternalHttpControllerCouponRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHttpControllerCouponResponse> {
            return localVarFp.authlanceLicenseAdminProductsSlugCouponsPost(slug, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifies a product and optionally registers additional coupons.
         * @summary Update product
         * @param {string} slug Product slug
         * @param {InternalHttpControllerProductRequest} payload Product definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseAdminProductsSlugPut(slug: string, payload: InternalHttpControllerProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<InternalHttpControllerProductResponse> {
            return localVarFp.authlanceLicenseAdminProductsSlugPut(slug, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the set of configured security product keys that can be associated with products.
         * @summary List product keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseProductKeysGet(options?: RawAxiosRequestConfig): AxiosPromise<InternalHttpControllerProductKeyListResponse> {
            return localVarFp.authlanceLicenseProductKeysGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Returns configured products with coupon metadata.
     * @summary List products
     * @param {boolean} [includeInactive] Include inactive products
     * @param {boolean} [includeInternal] Include internal products (sysadmin only)
     * @param {number} [page] Page number (default 1)
     * @param {number} [pageSize] Page size (default 20, max 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public authlanceLicenseAdminProductsGet(includeInactive?: boolean, includeInternal?: boolean, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).authlanceLicenseAdminProductsGet(includeInactive, includeInternal, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a product and optionally creates coupons.
     * @summary Create product
     * @param {InternalHttpControllerProductRequest} payload Product definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public authlanceLicenseAdminProductsPost(payload: InternalHttpControllerProductRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).authlanceLicenseAdminProductsPost(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current product seat utilization and remaining capacity.
     * @summary Get seat usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public authlanceLicenseAdminProductsSeatUsageGet(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).authlanceLicenseAdminProductsSeatUsageGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the specified coupon from the product.
     * @summary Delete coupon
     * @param {string} slug Product slug
     * @param {number} couponId Coupon identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public authlanceLicenseAdminProductsSlugCouponsCouponIdDelete(slug: string, couponId: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).authlanceLicenseAdminProductsSlugCouponsCouponIdDelete(slug, couponId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifies coupon metadata for the given product.
     * @summary Update coupon
     * @param {string} slug Product slug
     * @param {number} couponId Coupon identifier
     * @param {InternalHttpControllerCouponRequest} payload Coupon definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public authlanceLicenseAdminProductsSlugCouponsCouponIdPut(slug: string, couponId: number, payload: InternalHttpControllerCouponRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).authlanceLicenseAdminProductsSlugCouponsCouponIdPut(slug, couponId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists coupons configured for the specified product.
     * @summary List coupons
     * @param {string} slug Product slug
     * @param {boolean} [includeInactive] Include inactive coupons
     * @param {number} [page] Page number (default 1)
     * @param {number} [pageSize] Page size (default 20, max 100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public authlanceLicenseAdminProductsSlugCouponsGet(slug: string, includeInactive?: boolean, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).authlanceLicenseAdminProductsSlugCouponsGet(slug, includeInactive, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a coupon to the specified product.
     * @summary Create coupon
     * @param {string} slug Product slug
     * @param {InternalHttpControllerCouponRequest} payload Coupon definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public authlanceLicenseAdminProductsSlugCouponsPost(slug: string, payload: InternalHttpControllerCouponRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).authlanceLicenseAdminProductsSlugCouponsPost(slug, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifies a product and optionally registers additional coupons.
     * @summary Update product
     * @param {string} slug Product slug
     * @param {InternalHttpControllerProductRequest} payload Product definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public authlanceLicenseAdminProductsSlugPut(slug: string, payload: InternalHttpControllerProductRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).authlanceLicenseAdminProductsSlugPut(slug, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the set of configured security product keys that can be associated with products.
     * @summary List product keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public authlanceLicenseProductKeysGet(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).authlanceLicenseProductKeysGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InternalApi - axios parameter creator
 * @export
 */
export const InternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Issues a signed license and optionally persists it for retrieval.
         * @summary Issue license
         * @param {InternalHttpControllerIssueLicenseRequest} payload License issuance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseInternalIssuePost: async (payload: InternalHttpControllerIssueLicenseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceLicenseInternalIssuePost', 'payload', payload)
            const localVarPath = `/authlance/license/internal/issue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalApiAxiosParamCreator(configuration)
    return {
        /**
         * Issues a signed license and optionally persists it for retrieval.
         * @summary Issue license
         * @param {InternalHttpControllerIssueLicenseRequest} payload License issuance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseInternalIssuePost(payload: InternalHttpControllerIssueLicenseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseInternalIssuePost(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.authlanceLicenseInternalIssuePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalApiFp(configuration)
    return {
        /**
         * Issues a signed license and optionally persists it for retrieval.
         * @summary Issue license
         * @param {InternalHttpControllerIssueLicenseRequest} payload License issuance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseInternalIssuePost(payload: InternalHttpControllerIssueLicenseRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.authlanceLicenseInternalIssuePost(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
    /**
     * Issues a signed license and optionally persists it for retrieval.
     * @summary Issue license
     * @param {InternalHttpControllerIssueLicenseRequest} payload License issuance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public authlanceLicenseInternalIssuePost(payload: InternalHttpControllerIssueLicenseRequest, options?: RawAxiosRequestConfig) {
        return InternalApiFp(this.configuration).authlanceLicenseInternalIssuePost(payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LicenseApi - axios parameter creator
 * @export
 */
export const LicenseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List group licenses (simple)
         * @param {string} group Group name
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Page size (default 20, max 100)
         * @param {string} [plan] Filter by plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseGroupGet: async (group: string, page?: number, pageSize?: number, plan?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceLicenseGroupGet', 'group', group)
            const localVarPath = `/authlance/license/{group}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (plan !== undefined) {
                localVarQueryParameter['plan'] = plan;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List group licenses (paginated)
         * @param {string} groupName Group name
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Page size (default 20, max 100)
         * @param {string} [plan] Filter by plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseGroupsGroupNameLicensesGet: async (groupName: string, page?: number, pageSize?: number, plan?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupName' is not null or undefined
            assertParamExists('authlanceLicenseGroupsGroupNameLicensesGet', 'groupName', groupName)
            const localVarPath = `/authlance/license/groups/{groupName}/licenses`
                .replace(`{${"groupName"}}`, encodeURIComponent(String(groupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (plan !== undefined) {
                localVarQueryParameter['plan'] = plan;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get issued license
         * @param {string} identifier License ID (prefixed with L-) or group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseIdentifierGet: async (identifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('authlanceLicenseIdentifierGet', 'identifier', identifier)
            const localVarPath = `/authlance/license/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get issued license
         * @param {string} identifier License ID (prefixed with L-) or group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseIdentifierGet_1: async (identifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('authlanceLicenseIdentifierGet_1', 'identifier', identifier)
            const localVarPath = `/authlance/license/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get issued license
         * @param {string} licenseId License ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseLicenseIdGet: async (licenseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'licenseId' is not null or undefined
            assertParamExists('authlanceLicenseLicenseIdGet', 'licenseId', licenseId)
            const localVarPath = `/authlance/license/{licenseId}`
                .replace(`{${"licenseId"}}`, encodeURIComponent(String(licenseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get issued license
         * @param {string} licenseId License ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseLicenseIdGet_2: async (licenseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'licenseId' is not null or undefined
            assertParamExists('authlanceLicenseLicenseIdGet_2', 'licenseId', licenseId)
            const localVarPath = `/authlance/license/{licenseId}`
                .replace(`{${"licenseId"}}`, encodeURIComponent(String(licenseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Issue trial license
         * @param {string} group Group name
         * @param {InternalHttpControllerTrialIssueRequest} payload Trial issuance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseTrialGroupIssuePost: async (group: string, payload: InternalHttpControllerTrialIssueRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceLicenseTrialGroupIssuePost', 'group', group)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceLicenseTrialGroupIssuePost', 'payload', payload)
            const localVarPath = `/authlance/license/trial/{group}/issue`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LicenseApi - functional programming interface
 * @export
 */
export const LicenseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LicenseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List group licenses (simple)
         * @param {string} group Group name
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Page size (default 20, max 100)
         * @param {string} [plan] Filter by plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseGroupGet(group: string, page?: number, pageSize?: number, plan?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHttpControllerPaginatedLicenseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseGroupGet(group, page, pageSize, plan, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseApi.authlanceLicenseGroupGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List group licenses (paginated)
         * @param {string} groupName Group name
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Page size (default 20, max 100)
         * @param {string} [plan] Filter by plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseGroupsGroupNameLicensesGet(groupName: string, page?: number, pageSize?: number, plan?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHttpControllerPaginatedLicenseList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseGroupsGroupNameLicensesGet(groupName, page, pageSize, plan, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseApi.authlanceLicenseGroupsGroupNameLicensesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get issued license
         * @param {string} identifier License ID (prefixed with L-) or group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseIdentifierGet(identifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseIdentifierGet(identifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseApi.authlanceLicenseIdentifierGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get issued license
         * @param {string} identifier License ID (prefixed with L-) or group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseIdentifierGet_1(identifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseIdentifierGet_1(identifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseApi.authlanceLicenseIdentifierGet_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get issued license
         * @param {string} licenseId License ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseLicenseIdGet(licenseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseLicenseIdGet(licenseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseApi.authlanceLicenseLicenseIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get issued license
         * @param {string} licenseId License ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseLicenseIdGet_2(licenseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseLicenseIdGet_2(licenseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseApi.authlanceLicenseLicenseIdGet_2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Issue trial license
         * @param {string} group Group name
         * @param {InternalHttpControllerTrialIssueRequest} payload Trial issuance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseTrialGroupIssuePost(group: string, payload: InternalHttpControllerTrialIssueRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseTrialGroupIssuePost(group, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseApi.authlanceLicenseTrialGroupIssuePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LicenseApi - factory interface
 * @export
 */
export const LicenseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LicenseApiFp(configuration)
    return {
        /**
         * 
         * @summary List group licenses (simple)
         * @param {string} group Group name
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Page size (default 20, max 100)
         * @param {string} [plan] Filter by plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseGroupGet(group: string, page?: number, pageSize?: number, plan?: string, options?: RawAxiosRequestConfig): AxiosPromise<InternalHttpControllerPaginatedLicenseList> {
            return localVarFp.authlanceLicenseGroupGet(group, page, pageSize, plan, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List group licenses (paginated)
         * @param {string} groupName Group name
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Page size (default 20, max 100)
         * @param {string} [plan] Filter by plan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseGroupsGroupNameLicensesGet(groupName: string, page?: number, pageSize?: number, plan?: string, options?: RawAxiosRequestConfig): AxiosPromise<InternalHttpControllerPaginatedLicenseList> {
            return localVarFp.authlanceLicenseGroupsGroupNameLicensesGet(groupName, page, pageSize, plan, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get issued license
         * @param {string} identifier License ID (prefixed with L-) or group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseIdentifierGet(identifier: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.authlanceLicenseIdentifierGet(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get issued license
         * @param {string} identifier License ID (prefixed with L-) or group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseIdentifierGet_1(identifier: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.authlanceLicenseIdentifierGet_1(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get issued license
         * @param {string} licenseId License ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseLicenseIdGet(licenseId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.authlanceLicenseLicenseIdGet(licenseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get issued license
         * @param {string} licenseId License ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseLicenseIdGet_2(licenseId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.authlanceLicenseLicenseIdGet_2(licenseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Issue trial license
         * @param {string} group Group name
         * @param {InternalHttpControllerTrialIssueRequest} payload Trial issuance data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseTrialGroupIssuePost(group: string, payload: InternalHttpControllerTrialIssueRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.authlanceLicenseTrialGroupIssuePost(group, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LicenseApi - object-oriented interface
 * @export
 * @class LicenseApi
 * @extends {BaseAPI}
 */
export class LicenseApi extends BaseAPI {
    /**
     * 
     * @summary List group licenses (simple)
     * @param {string} group Group name
     * @param {number} [page] Page number (default 1)
     * @param {number} [pageSize] Page size (default 20, max 100)
     * @param {string} [plan] Filter by plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public authlanceLicenseGroupGet(group: string, page?: number, pageSize?: number, plan?: string, options?: RawAxiosRequestConfig) {
        return LicenseApiFp(this.configuration).authlanceLicenseGroupGet(group, page, pageSize, plan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List group licenses (paginated)
     * @param {string} groupName Group name
     * @param {number} [page] Page number (default 1)
     * @param {number} [pageSize] Page size (default 20, max 100)
     * @param {string} [plan] Filter by plan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public authlanceLicenseGroupsGroupNameLicensesGet(groupName: string, page?: number, pageSize?: number, plan?: string, options?: RawAxiosRequestConfig) {
        return LicenseApiFp(this.configuration).authlanceLicenseGroupsGroupNameLicensesGet(groupName, page, pageSize, plan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get issued license
     * @param {string} identifier License ID (prefixed with L-) or group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public authlanceLicenseIdentifierGet(identifier: string, options?: RawAxiosRequestConfig) {
        return LicenseApiFp(this.configuration).authlanceLicenseIdentifierGet(identifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get issued license
     * @param {string} identifier License ID (prefixed with L-) or group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public authlanceLicenseIdentifierGet_1(identifier: string, options?: RawAxiosRequestConfig) {
        return LicenseApiFp(this.configuration).authlanceLicenseIdentifierGet_1(identifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get issued license
     * @param {string} licenseId License ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public authlanceLicenseLicenseIdGet(licenseId: string, options?: RawAxiosRequestConfig) {
        return LicenseApiFp(this.configuration).authlanceLicenseLicenseIdGet(licenseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get issued license
     * @param {string} licenseId License ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public authlanceLicenseLicenseIdGet_2(licenseId: string, options?: RawAxiosRequestConfig) {
        return LicenseApiFp(this.configuration).authlanceLicenseLicenseIdGet_2(licenseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Issue trial license
     * @param {string} group Group name
     * @param {InternalHttpControllerTrialIssueRequest} payload Trial issuance data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public authlanceLicenseTrialGroupIssuePost(group: string, payload: InternalHttpControllerTrialIssueRequest, options?: RawAxiosRequestConfig) {
        return LicenseApiFp(this.configuration).authlanceLicenseTrialGroupIssuePost(group, payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Starts a hosted Stripe checkout session for purchasing a license tier.
         * @summary Create checkout session
         * @param {GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCheckoutSessionRequest} request Checkout session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicensePaymentsApiV1CheckoutSessionPost: async (request: GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCheckoutSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authlanceLicensePaymentsApiV1CheckoutSessionPost', 'request', request)
            const localVarPath = `/authlance/license/payments/api/v1/checkout-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Stripe billing portal session using the provided customer identifier.
         * @summary Create customer portal session
         * @param {GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCustomerPortalSessionRequest} request Customer portal request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicensePaymentsApiV1CustomerPortalPost: async (request: GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCustomerPortalSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authlanceLicensePaymentsApiV1CustomerPortalPost', 'request', request)
            const localVarPath = `/authlance/license/payments/api/v1/customer-portal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exports captured payments matching the filters as a CSV file.
         * @summary Export payments as CSV
         * @param {string} [from] Inclusive paid at lower bound (RFC3339 or YYYY-MM-DD)
         * @param {string} [to] Inclusive paid at upper bound (RFC3339 or YYYY-MM-DD)
         * @param {string} [productId] Filter by Stripe product id
         * @param {string} [organizationName] Filter by organization name
         * @param {string} [name] Filter by customer name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicensePaymentsApiV1ReportsPaymentsExportGet: async (from?: string, to?: string, productId?: string, organizationName?: string, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/license/payments/api/v1/reports/payments/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (organizationName !== undefined) {
                localVarQueryParameter['organizationName'] = organizationName;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated collection of captured payments with optional filters.
         * @summary List captured payments
         * @param {string} [from] Inclusive paid at lower bound (RFC3339 or YYYY-MM-DD)
         * @param {string} [to] Inclusive paid at upper bound (RFC3339 or YYYY-MM-DD)
         * @param {string} [productId] Filter by Stripe product id
         * @param {string} [organizationName] Filter by organization name
         * @param {string} [name] Filter by customer name
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Page size (default 50, max 500)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicensePaymentsApiV1ReportsPaymentsGet: async (from?: string, to?: string, productId?: string, organizationName?: string, name?: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/license/payments/api/v1/reports/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (organizationName !== undefined) {
                localVarQueryParameter['organizationName'] = organizationName;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolves a subscription identifier using a Stripe checkout session ID.
         * @summary Get subscription from session
         * @param {GithubComAuthlanceLicenseoperatorPkgPaymentsGetSubscriptionSessionRequest} request Session lookup request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicensePaymentsApiV1SessionIdPost: async (request: GithubComAuthlanceLicenseoperatorPkgPaymentsGetSubscriptionSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authlanceLicensePaymentsApiV1SessionIdPost', 'request', request)
            const localVarPath = `/authlance/license/payments/api/v1/session-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Stripe invoice, payment intent, and internal records for the given license.
         * @summary Verify license payment
         * @param {string} licenseId License identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicensePaymentsApiV1VerifyPaymentLicenseIdGet: async (licenseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'licenseId' is not null or undefined
            assertParamExists('authlanceLicensePaymentsApiV1VerifyPaymentLicenseIdGet', 'licenseId', licenseId)
            const localVarPath = `/authlance/license/payments/api/v1/verify-payment/{licenseId}`
                .replace(`{${"licenseId"}}`, encodeURIComponent(String(licenseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Stripe price/product metadata for the provided lookup key.
         * @summary Get checkout product details
         * @param {GithubComAuthlanceLicenseoperatorPkgPaymentsGetProductDetailsRequest} request Product details request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicensePaymentsProductDetailsPost: async (request: GithubComAuthlanceLicenseoperatorPkgPaymentsGetProductDetailsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authlanceLicensePaymentsProductDetailsPost', 'request', request)
            const localVarPath = `/authlance/license/payments/product-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Starts a hosted Stripe checkout session for purchasing a license tier.
         * @summary Create checkout session
         * @param {GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCheckoutSessionRequest} request Checkout session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicensePaymentsApiV1CheckoutSessionPost(request: GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCheckoutSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComAuthlanceLicenseoperatorPkgPaymentsStripeCheckoutSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicensePaymentsApiV1CheckoutSessionPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.authlanceLicensePaymentsApiV1CheckoutSessionPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Stripe billing portal session using the provided customer identifier.
         * @summary Create customer portal session
         * @param {GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCustomerPortalSessionRequest} request Customer portal request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicensePaymentsApiV1CustomerPortalPost(request: GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCustomerPortalSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCustomerPortalSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicensePaymentsApiV1CustomerPortalPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.authlanceLicensePaymentsApiV1CustomerPortalPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exports captured payments matching the filters as a CSV file.
         * @summary Export payments as CSV
         * @param {string} [from] Inclusive paid at lower bound (RFC3339 or YYYY-MM-DD)
         * @param {string} [to] Inclusive paid at upper bound (RFC3339 or YYYY-MM-DD)
         * @param {string} [productId] Filter by Stripe product id
         * @param {string} [organizationName] Filter by organization name
         * @param {string} [name] Filter by customer name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicensePaymentsApiV1ReportsPaymentsExportGet(from?: string, to?: string, productId?: string, organizationName?: string, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicensePaymentsApiV1ReportsPaymentsExportGet(from, to, productId, organizationName, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.authlanceLicensePaymentsApiV1ReportsPaymentsExportGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated collection of captured payments with optional filters.
         * @summary List captured payments
         * @param {string} [from] Inclusive paid at lower bound (RFC3339 or YYYY-MM-DD)
         * @param {string} [to] Inclusive paid at upper bound (RFC3339 or YYYY-MM-DD)
         * @param {string} [productId] Filter by Stripe product id
         * @param {string} [organizationName] Filter by organization name
         * @param {string} [name] Filter by customer name
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Page size (default 50, max 500)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicensePaymentsApiV1ReportsPaymentsGet(from?: string, to?: string, productId?: string, organizationName?: string, name?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicensePaymentsApiV1ReportsPaymentsGet(from, to, productId, organizationName, name, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.authlanceLicensePaymentsApiV1ReportsPaymentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resolves a subscription identifier using a Stripe checkout session ID.
         * @summary Get subscription from session
         * @param {GithubComAuthlanceLicenseoperatorPkgPaymentsGetSubscriptionSessionRequest} request Session lookup request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicensePaymentsApiV1SessionIdPost(request: GithubComAuthlanceLicenseoperatorPkgPaymentsGetSubscriptionSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComAuthlanceLicenseoperatorPkgPaymentsGetSubscriptionSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicensePaymentsApiV1SessionIdPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.authlanceLicensePaymentsApiV1SessionIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the Stripe invoice, payment intent, and internal records for the given license.
         * @summary Verify license payment
         * @param {string} licenseId License identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicensePaymentsApiV1VerifyPaymentLicenseIdGet(licenseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentVerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicensePaymentsApiV1VerifyPaymentLicenseIdGet(licenseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.authlanceLicensePaymentsApiV1VerifyPaymentLicenseIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns Stripe price/product metadata for the provided lookup key.
         * @summary Get checkout product details
         * @param {GithubComAuthlanceLicenseoperatorPkgPaymentsGetProductDetailsRequest} request Product details request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicensePaymentsProductDetailsPost(request: GithubComAuthlanceLicenseoperatorPkgPaymentsGetProductDetailsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GithubComAuthlanceLicenseoperatorPkgPaymentsGetProductDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicensePaymentsProductDetailsPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.authlanceLicensePaymentsProductDetailsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * Starts a hosted Stripe checkout session for purchasing a license tier.
         * @summary Create checkout session
         * @param {GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCheckoutSessionRequest} request Checkout session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicensePaymentsApiV1CheckoutSessionPost(request: GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCheckoutSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<GithubComAuthlanceLicenseoperatorPkgPaymentsStripeCheckoutSessionResponse> {
            return localVarFp.authlanceLicensePaymentsApiV1CheckoutSessionPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Stripe billing portal session using the provided customer identifier.
         * @summary Create customer portal session
         * @param {GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCustomerPortalSessionRequest} request Customer portal request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicensePaymentsApiV1CustomerPortalPost(request: GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCustomerPortalSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCustomerPortalSessionResponse> {
            return localVarFp.authlanceLicensePaymentsApiV1CustomerPortalPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Exports captured payments matching the filters as a CSV file.
         * @summary Export payments as CSV
         * @param {string} [from] Inclusive paid at lower bound (RFC3339 or YYYY-MM-DD)
         * @param {string} [to] Inclusive paid at upper bound (RFC3339 or YYYY-MM-DD)
         * @param {string} [productId] Filter by Stripe product id
         * @param {string} [organizationName] Filter by organization name
         * @param {string} [name] Filter by customer name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicensePaymentsApiV1ReportsPaymentsExportGet(from?: string, to?: string, productId?: string, organizationName?: string, name?: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.authlanceLicensePaymentsApiV1ReportsPaymentsExportGet(from, to, productId, organizationName, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated collection of captured payments with optional filters.
         * @summary List captured payments
         * @param {string} [from] Inclusive paid at lower bound (RFC3339 or YYYY-MM-DD)
         * @param {string} [to] Inclusive paid at upper bound (RFC3339 or YYYY-MM-DD)
         * @param {string} [productId] Filter by Stripe product id
         * @param {string} [organizationName] Filter by organization name
         * @param {string} [name] Filter by customer name
         * @param {number} [page] Page number (default 1)
         * @param {number} [pageSize] Page size (default 50, max 500)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicensePaymentsApiV1ReportsPaymentsGet(from?: string, to?: string, productId?: string, organizationName?: string, name?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentsPage> {
            return localVarFp.authlanceLicensePaymentsApiV1ReportsPaymentsGet(from, to, productId, organizationName, name, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Resolves a subscription identifier using a Stripe checkout session ID.
         * @summary Get subscription from session
         * @param {GithubComAuthlanceLicenseoperatorPkgPaymentsGetSubscriptionSessionRequest} request Session lookup request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicensePaymentsApiV1SessionIdPost(request: GithubComAuthlanceLicenseoperatorPkgPaymentsGetSubscriptionSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<GithubComAuthlanceLicenseoperatorPkgPaymentsGetSubscriptionSessionResponse> {
            return localVarFp.authlanceLicensePaymentsApiV1SessionIdPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Stripe invoice, payment intent, and internal records for the given license.
         * @summary Verify license payment
         * @param {string} licenseId License identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicensePaymentsApiV1VerifyPaymentLicenseIdGet(licenseId: string, options?: RawAxiosRequestConfig): AxiosPromise<GithubComAuthlanceLicenseoperatorPkgPaymentsPaymentVerificationResponse> {
            return localVarFp.authlanceLicensePaymentsApiV1VerifyPaymentLicenseIdGet(licenseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Stripe price/product metadata for the provided lookup key.
         * @summary Get checkout product details
         * @param {GithubComAuthlanceLicenseoperatorPkgPaymentsGetProductDetailsRequest} request Product details request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicensePaymentsProductDetailsPost(request: GithubComAuthlanceLicenseoperatorPkgPaymentsGetProductDetailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GithubComAuthlanceLicenseoperatorPkgPaymentsGetProductDetailsResponse> {
            return localVarFp.authlanceLicensePaymentsProductDetailsPost(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * Starts a hosted Stripe checkout session for purchasing a license tier.
     * @summary Create checkout session
     * @param {GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCheckoutSessionRequest} request Checkout session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public authlanceLicensePaymentsApiV1CheckoutSessionPost(request: GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCheckoutSessionRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).authlanceLicensePaymentsApiV1CheckoutSessionPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Stripe billing portal session using the provided customer identifier.
     * @summary Create customer portal session
     * @param {GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCustomerPortalSessionRequest} request Customer portal request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public authlanceLicensePaymentsApiV1CustomerPortalPost(request: GithubComAuthlanceLicenseoperatorPkgPaymentsCreateCustomerPortalSessionRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).authlanceLicensePaymentsApiV1CustomerPortalPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exports captured payments matching the filters as a CSV file.
     * @summary Export payments as CSV
     * @param {string} [from] Inclusive paid at lower bound (RFC3339 or YYYY-MM-DD)
     * @param {string} [to] Inclusive paid at upper bound (RFC3339 or YYYY-MM-DD)
     * @param {string} [productId] Filter by Stripe product id
     * @param {string} [organizationName] Filter by organization name
     * @param {string} [name] Filter by customer name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public authlanceLicensePaymentsApiV1ReportsPaymentsExportGet(from?: string, to?: string, productId?: string, organizationName?: string, name?: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).authlanceLicensePaymentsApiV1ReportsPaymentsExportGet(from, to, productId, organizationName, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated collection of captured payments with optional filters.
     * @summary List captured payments
     * @param {string} [from] Inclusive paid at lower bound (RFC3339 or YYYY-MM-DD)
     * @param {string} [to] Inclusive paid at upper bound (RFC3339 or YYYY-MM-DD)
     * @param {string} [productId] Filter by Stripe product id
     * @param {string} [organizationName] Filter by organization name
     * @param {string} [name] Filter by customer name
     * @param {number} [page] Page number (default 1)
     * @param {number} [pageSize] Page size (default 50, max 500)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public authlanceLicensePaymentsApiV1ReportsPaymentsGet(from?: string, to?: string, productId?: string, organizationName?: string, name?: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).authlanceLicensePaymentsApiV1ReportsPaymentsGet(from, to, productId, organizationName, name, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resolves a subscription identifier using a Stripe checkout session ID.
     * @summary Get subscription from session
     * @param {GithubComAuthlanceLicenseoperatorPkgPaymentsGetSubscriptionSessionRequest} request Session lookup request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public authlanceLicensePaymentsApiV1SessionIdPost(request: GithubComAuthlanceLicenseoperatorPkgPaymentsGetSubscriptionSessionRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).authlanceLicensePaymentsApiV1SessionIdPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the Stripe invoice, payment intent, and internal records for the given license.
     * @summary Verify license payment
     * @param {string} licenseId License identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public authlanceLicensePaymentsApiV1VerifyPaymentLicenseIdGet(licenseId: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).authlanceLicensePaymentsApiV1VerifyPaymentLicenseIdGet(licenseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Stripe price/product metadata for the provided lookup key.
     * @summary Get checkout product details
     * @param {GithubComAuthlanceLicenseoperatorPkgPaymentsGetProductDetailsRequest} request Product details request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public authlanceLicensePaymentsProductDetailsPost(request: GithubComAuthlanceLicenseoperatorPkgPaymentsGetProductDetailsRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).authlanceLicensePaymentsProductDetailsPost(request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PublicApi - axios parameter creator
 * @export
 */
export const PublicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get product details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseProductGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/license/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns active, non-internal products including marketing-friendly coupon metadata.
         * @summary List public products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseProductsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/license/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicApi - functional programming interface
 * @export
 */
export const PublicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get product details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseProductGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternalHttpControllerProductDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseProductGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.authlanceLicenseProductGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns active, non-internal products including marketing-friendly coupon metadata.
         * @summary List public products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseProductsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InternalHttpControllerPublicProductResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseProductsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicApi.authlanceLicenseProductsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PublicApi - factory interface
 * @export
 */
export const PublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicApiFp(configuration)
    return {
        /**
         * 
         * @summary Get product details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseProductGet(options?: RawAxiosRequestConfig): AxiosPromise<InternalHttpControllerProductDetailsResponse> {
            return localVarFp.authlanceLicenseProductGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns active, non-internal products including marketing-friendly coupon metadata.
         * @summary List public products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseProductsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<InternalHttpControllerPublicProductResponse>> {
            return localVarFp.authlanceLicenseProductsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicApi - object-oriented interface
 * @export
 * @class PublicApi
 * @extends {BaseAPI}
 */
export class PublicApi extends BaseAPI {
    /**
     * 
     * @summary Get product details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public authlanceLicenseProductGet(options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).authlanceLicenseProductGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns active, non-internal products including marketing-friendly coupon metadata.
     * @summary List public products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicApi
     */
    public authlanceLicenseProductsGet(options?: RawAxiosRequestConfig) {
        return PublicApiFp(this.configuration).authlanceLicenseProductsGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StripeApi - axios parameter creator
 * @export
 */
export const StripeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Stripe webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseStripeWebhookPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/license/stripe/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Stripe webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceLicenseStripeWebhookPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceLicenseStripeWebhookPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeApi.authlanceLicenseStripeWebhookPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeApiFp(configuration)
    return {
        /**
         * 
         * @summary Stripe webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceLicenseStripeWebhookPost(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.authlanceLicenseStripeWebhookPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
    /**
     * 
     * @summary Stripe webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public authlanceLicenseStripeWebhookPost(options?: RawAxiosRequestConfig) {
        return StripeApiFp(this.configuration).authlanceLicenseStripeWebhookPost(options).then((request) => request(this.axios, this.basePath));
    }
}



