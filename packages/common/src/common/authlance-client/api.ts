/* tslint:disable */
/* eslint-disable */
/**
 * Authlance API
 * Identity, users, groups and subscriptions API for Authlance.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CommonGroup
 */
export interface CommonGroup {
    /**
     * 
     * @type {string}
     * @memberof CommonGroup
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonGroup
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof CommonGroup
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CommonGroup
     */
    'longName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonGroup
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonGroup
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface CommonGroupMemberRole
 */
export interface CommonGroupMemberRole {
    /**
     * 
     * @type {string}
     * @memberof CommonGroupMemberRole
     */
    'group'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonGroupMemberRole
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonGroupMemberRole
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CommonIdentityState = {
    IdentityStateActive: 'active',
    IdentityStateInactive: 'inactive'
} as const;

export type CommonIdentityState = typeof CommonIdentityState[keyof typeof CommonIdentityState];


/**
 * 
 * @export
 * @interface CommonStripeProductDetails
 */
export interface CommonStripeProductDetails {
    /**
     * 
     * @type {boolean}
     * @memberof CommonStripeProductDetails
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CommonStripeProductDetails
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonStripeProductDetails
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonStripeProductDetails
     */
    'lookup_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonStripeProductDetails
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonStripeProductDetails
     */
    'object'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CommonStripeProductDetails
     */
    'product'?: { [key: string]: any; };
    /**
     * 
     * @type {CommonStripeRecurring}
     * @memberof CommonStripeProductDetails
     */
    'recurring'?: CommonStripeRecurring;
    /**
     * 
     * @type {string}
     * @memberof CommonStripeProductDetails
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof CommonStripeProductDetails
     */
    'unit_amount'?: number;
}
/**
 * 
 * @export
 * @interface CommonStripeRecurring
 */
export interface CommonStripeRecurring {
    /**
     * 
     * @type {string}
     * @memberof CommonStripeRecurring
     */
    'interval'?: string;
    /**
     * 
     * @type {number}
     * @memberof CommonStripeRecurring
     */
    'interval_count'?: number;
}
/**
 * 
 * @export
 * @interface CommonUser
 */
export interface CommonUser {
    /**
     * 
     * @type {string}
     * @memberof CommonUser
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonUser
     */
    'birthDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonUser
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonUser
     */
    'gender'?: string;
    /**
     * 
     * @type {Array<CommonUserGroupRole>}
     * @memberof CommonUser
     */
    'groupRoles'?: Array<CommonUserGroupRole>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CommonUser
     */
    'groups'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CommonUser
     */
    'identity'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonUser
     */
    'lastName'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CommonUser
     */
    'roles'?: Array<string>;
    /**
     * 
     * @type {CommonIdentityState}
     * @memberof CommonUser
     */
    'state'?: CommonIdentityState;
    /**
     * 
     * @type {boolean}
     * @memberof CommonUser
     */
    'verified'?: boolean;
}


/**
 * 
 * @export
 * @interface CommonUserGroupRole
 */
export interface CommonUserGroupRole {
    /**
     * 
     * @type {string}
     * @memberof CommonUserGroupRole
     */
    'group'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonUserGroupRole
     */
    'role'?: string;
}
/**
 * 
 * @export
 * @interface ControllersAuthAuthRequest
 */
export interface ControllersAuthAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof ControllersAuthAuthRequest
     */
    'session'?: string;
}
/**
 * 
 * @export
 * @interface ControllersAuthAuthResponse
 */
export interface ControllersAuthAuthResponse {
    /**
     * 
     * @type {string}
     * @memberof ControllersAuthAuthResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface ControllersAuthLogoutResponse
 */
export interface ControllersAuthLogoutResponse {
    /**
     * 
     * @type {string}
     * @memberof ControllersAuthLogoutResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ControllersLicenseLicenseStatusResponse
 */
export interface ControllersLicenseLicenseStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof ControllersLicenseLicenseStatusResponse
     */
    'lastError'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersLicenseLicenseStatusResponse
     */
    'state'?: string;
    /**
     * 
     * @type {LicenseStatus}
     * @memberof ControllersLicenseLicenseStatusResponse
     */
    'status'?: LicenseStatus;
    /**
     * 
     * @type {string}
     * @memberof ControllersLicenseLicenseStatusResponse
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface ControllersLicenseUpdateLicenseRequest
 */
export interface ControllersLicenseUpdateLicenseRequest {
    /**
     * 
     * @type {string}
     * @memberof ControllersLicenseUpdateLicenseRequest
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest
 */
export interface ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest {
    /**
     * 
     * @type {number}
     * @memberof ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest
     */
    'expiresInDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest
     */
    'groupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest
     */
    'scopes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ControllersPersonalaccesstokensPersonalAccessTokenResponse
 */
export interface ControllersPersonalaccesstokensPersonalAccessTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'displayOnceShown'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'effectiveScope'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'groupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'lastUsedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'revokedAt'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'scopes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'tokenPrefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest
 */
export interface ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
 */
export interface ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'effectiveScope'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'groupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'lastUsedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'revokedAt'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'scopes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'tokenId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'tokenPrefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface ControllersUsersBanUserRequest
 */
export interface ControllersUsersBanUserRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ControllersUsersBanUserRequest
     */
    'revokeSessions'?: boolean;
}
/**
 * 
 * @export
 * @interface ControllersUsersRoleAssignmentPayload
 */
export interface ControllersUsersRoleAssignmentPayload {
    /**
     * 
     * @type {string}
     * @memberof ControllersUsersRoleAssignmentPayload
     */
    'identity'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ControllersUsersRoleAssignmentPayload
     */
    'roles'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonCreateCheckoutSessionRequest
 */
export interface DunaAuthCommonCreateCheckoutSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonCreateCheckoutSessionRequest
     */
    'lookupKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonCreateCheckoutSessionRequest
     */
    'organizationLongName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonCreateCheckoutSessionRequest
     */
    'organizationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonCreateCheckoutSessionRequest
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonCreateCheckoutSessionResponse
 */
export interface DunaAuthCommonCreateCheckoutSessionResponse {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonCreateCheckoutSessionResponse
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonCreateCustomerPortalSessionRequest
 */
export interface DunaAuthCommonCreateCustomerPortalSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonCreateCustomerPortalSessionRequest
     */
    'customerId'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonCreateCustomerPortalSessionResponse
 */
export interface DunaAuthCommonCreateCustomerPortalSessionResponse {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonCreateCustomerPortalSessionResponse
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGetProductDetailsRequest
 */
export interface DunaAuthCommonGetProductDetailsRequest {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGetProductDetailsRequest
     */
    'lookup_key'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGetProductDetailsResponse
 */
export interface DunaAuthCommonGetProductDetailsResponse {
    /**
     * 
     * @type {CommonStripeProductDetails}
     * @memberof DunaAuthCommonGetProductDetailsResponse
     */
    'product'?: CommonStripeProductDetails;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGetSubscriptionSessionRequest
 */
export interface DunaAuthCommonGetSubscriptionSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGetSubscriptionSessionRequest
     */
    'sessionId'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGetSubscriptionSessionResponse
 */
export interface DunaAuthCommonGetSubscriptionSessionResponse {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGetSubscriptionSessionResponse
     */
    'subscriptionId'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGroup
 */
export interface DunaAuthCommonGroup {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroup
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroup
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonGroup
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroup
     */
    'longName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroup
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroup
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGroupAvailabilityResponse
 */
export interface DunaAuthCommonGroupAvailabilityResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DunaAuthCommonGroupAvailabilityResponse
     */
    'available'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroupAvailabilityResponse
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGroupMemberRolesResponse
 */
export interface DunaAuthCommonGroupMemberRolesResponse {
    /**
     * 
     * @type {Array<CommonGroupMemberRole>}
     * @memberof DunaAuthCommonGroupMemberRolesResponse
     */
    'groupRoles'?: Array<CommonGroupMemberRole>;
    /**
     * 
     * @type {CommonUser}
     * @memberof DunaAuthCommonGroupMemberRolesResponse
     */
    'user'?: CommonUser;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGroupMembershipRolesListResponse
 */
export interface DunaAuthCommonGroupMembershipRolesListResponse {
    /**
     * 
     * @type {Array<CommonGroupMemberRole>}
     * @memberof DunaAuthCommonGroupMembershipRolesListResponse
     */
    'groupRoles'?: Array<CommonGroupMemberRole>;
    /**
     * 
     * @type {Array<CommonUser>}
     * @memberof DunaAuthCommonGroupMembershipRolesListResponse
     */
    'users'?: Array<CommonUser>;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGroupSubscriptionsDto
 */
export interface DunaAuthCommonGroupSubscriptionsDto {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'billingCustomerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'billingProvider'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'billingSubscriptionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'endDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'groupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'subscriptionId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'tierName'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGroupsPageResponse
 */
export interface DunaAuthCommonGroupsPageResponse {
    /**
     * 
     * @type {Array<CommonGroup>}
     * @memberof DunaAuthCommonGroupsPageResponse
     */
    'groups'?: Array<CommonGroup>;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonGroupsPageResponse
     */
    'pages'?: number;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonIdentityStateResponse
 */
export interface DunaAuthCommonIdentityStateResponse {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonIdentityStateResponse
     */
    'identity'?: string;
    /**
     * 
     * @type {CommonIdentityState}
     * @memberof DunaAuthCommonIdentityStateResponse
     */
    'state'?: CommonIdentityState;
}


/**
 * 
 * @export
 * @interface DunaAuthCommonPaymentTierDto
 */
export interface DunaAuthCommonPaymentTierDto {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonPaymentTierDto
     */
    'billingCycle'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonPaymentTierDto
     */
    'lookupKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonPaymentTierDto
     */
    'maxMembers'?: number;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonPaymentTierDto
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonPaymentTierDto
     */
    'tierDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonPaymentTierDto
     */
    'tierName'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonRoleResponse
 */
export interface DunaAuthCommonRoleResponse {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonRoleResponse
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonRolesPageResponse
 */
export interface DunaAuthCommonRolesPageResponse {
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonRolesPageResponse
     */
    'pages'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DunaAuthCommonRolesPageResponse
     */
    'roles'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonUser
 */
export interface DunaAuthCommonUser {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonUser
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonUser
     */
    'birthDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonUser
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonUser
     */
    'gender'?: string;
    /**
     * 
     * @type {Array<CommonUserGroupRole>}
     * @memberof DunaAuthCommonUser
     */
    'groupRoles'?: Array<CommonUserGroupRole>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DunaAuthCommonUser
     */
    'groups'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonUser
     */
    'identity'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonUser
     */
    'lastName'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DunaAuthCommonUser
     */
    'roles'?: Array<string>;
    /**
     * 
     * @type {CommonIdentityState}
     * @memberof DunaAuthCommonUser
     */
    'state'?: CommonIdentityState;
    /**
     * 
     * @type {boolean}
     * @memberof DunaAuthCommonUser
     */
    'verified'?: boolean;
}


/**
 * 
 * @export
 * @interface DunaAuthCommonUsersPageResponse
 */
export interface DunaAuthCommonUsersPageResponse {
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonUsersPageResponse
     */
    'pages'?: number;
    /**
     * 
     * @type {Array<CommonUser>}
     * @memberof DunaAuthCommonUsersPageResponse
     */
    'users'?: Array<CommonUser>;
}
/**
 * 
 * @export
 * @interface LicenseStatus
 */
export interface LicenseStatus {
    /**
     * 
     * @type {number}
     * @memberof LicenseStatus
     */
    'daysRemaining'?: number;
    /**
     * 
     * @type {string}
     * @memberof LicenseStatus
     */
    'domain'?: string;
    /**
     * 
     * @type {string}
     * @memberof LicenseStatus
     */
    'exp'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LicenseStatus
     */
    'grace'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LicenseStatus
     */
    'licenseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof LicenseStatus
     */
    'plan'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LicenseStatus
     */
    'valid'?: boolean;
}

/**
 * AdminGroupsApi - axios parameter creator
 * @export
 */
export const AdminGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows admins to check if a group slug is free before provisioning the group.
         * @summary Check if a group name is available (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupAvailableGet: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupAvailableGet', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/admin/group/{group}/available`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns group metadata along with administrative attributes.
         * @summary Get group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupGet: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupGet', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/admin/group/{group}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the specified user from the target group and updates their membership cache.
         * @summary Remove user from group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupMembersDelete: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupMembersDelete', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/admin/group/{group}/members`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the users inside the given group, including admin-only metadata.
         * @summary List group members (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupMembersGet: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupMembersGet', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/admin/group/{group}/members`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds (or invites) a user to the target group, creating the account when needed.
         * @summary Add user to group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupMembersPost: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupMembersPost', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/admin/group/{group}/members`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates any group metadata, including avatar uploads, as an administrator.
         * @summary Update group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupPost: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupPost', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/admin/group/{group}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the set of roles granted to a group member. Requires admin privileges.
         * @summary Assign roles to group member (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupRolePost: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupRolePost', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/admin/group/{group}/role`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the roles granted to the specified user inside the given group. Requires admin privileges.
         * @summary Get a member\'s roles in a group (admin)
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupRoleUserGet: async (group: string, user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupRoleUserGet', 'group', group)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupRoleUserGet', 'user', user)
            const localVarPath = `/authlance/identity/api/v1/admin/group/{group}/role/{user}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all groups for the specified identity. Useful for administrative audits.
         * @summary List groups for identity
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupMemberIdentityGet: async (identity: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupMemberIdentityGet', 'identity', identity)
            const localVarPath = `/authlance/identity/api/v1/admin/group/member/{identity}`
                .replace(`{${"identity"}}`, encodeURIComponent(String(identity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new group using the provided display name. The logical slug is normalized automatically.
         * @summary Create group
         * @param {DunaAuthCommonGroup} payload Group to create (id &#x3D; -1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupPut: async (payload: DunaAuthCommonGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupPut', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/admin/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists each member within the group alongside their assigned roles.
         * @summary List roles assigned within a group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupRolesGroupGet: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupRolesGroupGet', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/admin/group/roles/{group}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Paginates through groups with optional filters by name.
         * @summary List groups
         * @param {number} page Page number
         * @param {number} [perPage] Per-page size
         * @param {string} [filter] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupsPageGet: async (page: number, perPage?: number, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupsPageGet', 'page', page)
            const localVarPath = `/authlance/identity/api/v1/admin/groups/{page}`
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminGroupsApi - functional programming interface
 * @export
 */
export const AdminGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows admins to check if a group slug is free before provisioning the group.
         * @summary Check if a group name is available (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupGroupAvailableGet(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupAvailabilityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupGroupAvailableGet(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupGroupAvailableGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns group metadata along with administrative attributes.
         * @summary Get group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupGroupGet(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupGroupGet(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupGroupGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the specified user from the target group and updates their membership cache.
         * @summary Remove user from group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupGroupMembersDelete(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupGroupMembersDelete(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupGroupMembersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists the users inside the given group, including admin-only metadata.
         * @summary List group members (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupGroupMembersGet(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DunaAuthCommonUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupGroupMembersGet(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupGroupMembersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds (or invites) a user to the target group, creating the account when needed.
         * @summary Add user to group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupGroupMembersPost(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupGroupMembersPost(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupGroupMembersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates any group metadata, including avatar uploads, as an administrator.
         * @summary Update group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupGroupPost(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupGroupPost(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupGroupPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replaces the set of roles granted to a group member. Requires admin privileges.
         * @summary Assign roles to group member (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupGroupRolePost(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupGroupRolePost(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupGroupRolePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the roles granted to the specified user inside the given group. Requires admin privileges.
         * @summary Get a member\'s roles in a group (admin)
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupMemberRolesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupGroupRoleUserGet(group, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupGroupRoleUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all groups for the specified identity. Useful for administrative audits.
         * @summary List groups for identity
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupMemberIdentityGet(identity: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DunaAuthCommonGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupMemberIdentityGet(identity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupMemberIdentityGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new group using the provided display name. The logical slug is normalized automatically.
         * @summary Create group
         * @param {DunaAuthCommonGroup} payload Group to create (id &#x3D; -1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupPut(payload: DunaAuthCommonGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupPut(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists each member within the group alongside their assigned roles.
         * @summary List roles assigned within a group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupRolesGroupGet(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupMembershipRolesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupRolesGroupGet(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupRolesGroupGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Paginates through groups with optional filters by name.
         * @summary List groups
         * @param {number} page Page number
         * @param {number} [perPage] Per-page size
         * @param {string} [filter] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupsPageGet(page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupsPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupsPageGet(page, perPage, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupsPageGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminGroupsApi - factory interface
 * @export
 */
export const AdminGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminGroupsApiFp(configuration)
    return {
        /**
         * Allows admins to check if a group slug is free before provisioning the group.
         * @summary Check if a group name is available (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupAvailableGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupAvailabilityResponse> {
            return localVarFp.authlanceIdentityApiV1AdminGroupGroupAvailableGet(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns group metadata along with administrative attributes.
         * @summary Get group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup> {
            return localVarFp.authlanceIdentityApiV1AdminGroupGroupGet(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the specified user from the target group and updates their membership cache.
         * @summary Remove user from group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupMembersDelete(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1AdminGroupGroupMembersDelete(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the users inside the given group, including admin-only metadata.
         * @summary List group members (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupMembersGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonUser>> {
            return localVarFp.authlanceIdentityApiV1AdminGroupGroupMembersGet(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds (or invites) a user to the target group, creating the account when needed.
         * @summary Add user to group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupMembersPost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1AdminGroupGroupMembersPost(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates any group metadata, including avatar uploads, as an administrator.
         * @summary Update group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupPost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup> {
            return localVarFp.authlanceIdentityApiV1AdminGroupGroupPost(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the set of roles granted to a group member. Requires admin privileges.
         * @summary Assign roles to group member (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupRolePost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1AdminGroupGroupRolePost(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the roles granted to the specified user inside the given group. Requires admin privileges.
         * @summary Get a member\'s roles in a group (admin)
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMemberRolesResponse> {
            return localVarFp.authlanceIdentityApiV1AdminGroupGroupRoleUserGet(group, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all groups for the specified identity. Useful for administrative audits.
         * @summary List groups for identity
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupMemberIdentityGet(identity: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonGroup>> {
            return localVarFp.authlanceIdentityApiV1AdminGroupMemberIdentityGet(identity, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new group using the provided display name. The logical slug is normalized automatically.
         * @summary Create group
         * @param {DunaAuthCommonGroup} payload Group to create (id &#x3D; -1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupPut(payload: DunaAuthCommonGroup, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup> {
            return localVarFp.authlanceIdentityApiV1AdminGroupPut(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists each member within the group alongside their assigned roles.
         * @summary List roles assigned within a group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupRolesGroupGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMembershipRolesListResponse> {
            return localVarFp.authlanceIdentityApiV1AdminGroupRolesGroupGet(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Paginates through groups with optional filters by name.
         * @summary List groups
         * @param {number} page Page number
         * @param {number} [perPage] Per-page size
         * @param {string} [filter] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupsPageGet(page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupsPageResponse> {
            return localVarFp.authlanceIdentityApiV1AdminGroupsPageGet(page, perPage, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminGroupsApi - interface
 * @export
 * @interface AdminGroupsApi
 */
export interface AdminGroupsApiInterface {
    /**
     * Allows admins to check if a group slug is free before provisioning the group.
     * @summary Check if a group name is available (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupGroupAvailableGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupAvailabilityResponse>;

    /**
     * Returns group metadata along with administrative attributes.
     * @summary Get group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupGroupGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup>;

    /**
     * Removes the specified user from the target group and updates their membership cache.
     * @summary Remove user from group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupGroupMembersDelete(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Lists the users inside the given group, including admin-only metadata.
     * @summary List group members (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupGroupMembersGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonUser>>;

    /**
     * Adds (or invites) a user to the target group, creating the account when needed.
     * @summary Add user to group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupGroupMembersPost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Updates any group metadata, including avatar uploads, as an administrator.
     * @summary Update group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupGroupPost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup>;

    /**
     * Replaces the set of roles granted to a group member. Requires admin privileges.
     * @summary Assign roles to group member (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupGroupRolePost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Returns the roles granted to the specified user inside the given group. Requires admin privileges.
     * @summary Get a member\'s roles in a group (admin)
     * @param {string} group Group name
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMemberRolesResponse>;

    /**
     * Lists all groups for the specified identity. Useful for administrative audits.
     * @summary List groups for identity
     * @param {string} identity Identity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupMemberIdentityGet(identity: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonGroup>>;

    /**
     * Creates a new group using the provided display name. The logical slug is normalized automatically.
     * @summary Create group
     * @param {DunaAuthCommonGroup} payload Group to create (id &#x3D; -1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupPut(payload: DunaAuthCommonGroup, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup>;

    /**
     * Lists each member within the group alongside their assigned roles.
     * @summary List roles assigned within a group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupRolesGroupGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMembershipRolesListResponse>;

    /**
     * Paginates through groups with optional filters by name.
     * @summary List groups
     * @param {number} page Page number
     * @param {number} [perPage] Per-page size
     * @param {string} [filter] Filter by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupsPageGet(page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupsPageResponse>;

}

/**
 * AdminGroupsApi - object-oriented interface
 * @export
 * @class AdminGroupsApi
 * @extends {BaseAPI}
 */
export class AdminGroupsApi extends BaseAPI implements AdminGroupsApiInterface {
    /**
     * Allows admins to check if a group slug is free before provisioning the group.
     * @summary Check if a group name is available (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupGroupAvailableGet(group: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupGroupAvailableGet(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns group metadata along with administrative attributes.
     * @summary Get group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupGroupGet(group: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupGroupGet(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the specified user from the target group and updates their membership cache.
     * @summary Remove user from group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupGroupMembersDelete(group: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupGroupMembersDelete(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the users inside the given group, including admin-only metadata.
     * @summary List group members (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupGroupMembersGet(group: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupGroupMembersGet(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds (or invites) a user to the target group, creating the account when needed.
     * @summary Add user to group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupGroupMembersPost(group: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupGroupMembersPost(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates any group metadata, including avatar uploads, as an administrator.
     * @summary Update group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupGroupPost(group: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupGroupPost(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the set of roles granted to a group member. Requires admin privileges.
     * @summary Assign roles to group member (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupGroupRolePost(group: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupGroupRolePost(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the roles granted to the specified user inside the given group. Requires admin privileges.
     * @summary Get a member\'s roles in a group (admin)
     * @param {string} group Group name
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupGroupRoleUserGet(group, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all groups for the specified identity. Useful for administrative audits.
     * @summary List groups for identity
     * @param {string} identity Identity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupMemberIdentityGet(identity: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupMemberIdentityGet(identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new group using the provided display name. The logical slug is normalized automatically.
     * @summary Create group
     * @param {DunaAuthCommonGroup} payload Group to create (id &#x3D; -1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupPut(payload: DunaAuthCommonGroup, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupPut(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists each member within the group alongside their assigned roles.
     * @summary List roles assigned within a group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupRolesGroupGet(group: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupRolesGroupGet(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Paginates through groups with optional filters by name.
     * @summary List groups
     * @param {number} page Page number
     * @param {number} [perPage] Per-page size
     * @param {string} [filter] Filter by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupsPageGet(page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupsPageGet(page, perPage, filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminRolesApi - axios parameter creator
 * @export
 */
export const AdminRolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Registers a new platform role that can later be assigned to identities.
         * @summary Create role
         * @param {DunaAuthCommonRoleResponse} payload { name: roleName }
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminRolePut: async (payload: DunaAuthCommonRoleResponse, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminRolePut', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/admin/role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists platform roles available for assignment, including pagination and filters.
         * @summary List system roles (admin)
         * @param {number} page Page number
         * @param {number} [perPage] Page size
         * @param {string} [filter] Text filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminRolesPageGet: async (page: number, perPage?: number, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminRolesPageGet', 'page', page)
            const localVarPath = `/authlance/identity/api/v1/admin/roles/{page}`
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the set of global roles attached to the specified identity.
         * @summary Assign roles to user
         * @param {ControllersUsersRoleAssignmentPayload} payload Identity and roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserRolePut: async (payload: ControllersUsersRoleAssignmentPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminUserRolePut', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/admin/user/role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminRolesApi - functional programming interface
 * @export
 */
export const AdminRolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminRolesApiAxiosParamCreator(configuration)
    return {
        /**
         * Registers a new platform role that can later be assigned to identities.
         * @summary Create role
         * @param {DunaAuthCommonRoleResponse} payload { name: roleName }
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminRolePut(payload: DunaAuthCommonRoleResponse, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminRolePut(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminRolesApi.authlanceIdentityApiV1AdminRolePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists platform roles available for assignment, including pagination and filters.
         * @summary List system roles (admin)
         * @param {number} page Page number
         * @param {number} [perPage] Page size
         * @param {string} [filter] Text filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminRolesPageGet(page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonRolesPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminRolesPageGet(page, perPage, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminRolesApi.authlanceIdentityApiV1AdminRolesPageGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replaces the set of global roles attached to the specified identity.
         * @summary Assign roles to user
         * @param {ControllersUsersRoleAssignmentPayload} payload Identity and roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminUserRolePut(payload: ControllersUsersRoleAssignmentPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminUserRolePut(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminRolesApi.authlanceIdentityApiV1AdminUserRolePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminRolesApi - factory interface
 * @export
 */
export const AdminRolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminRolesApiFp(configuration)
    return {
        /**
         * Registers a new platform role that can later be assigned to identities.
         * @summary Create role
         * @param {DunaAuthCommonRoleResponse} payload { name: roleName }
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminRolePut(payload: DunaAuthCommonRoleResponse, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonRoleResponse> {
            return localVarFp.authlanceIdentityApiV1AdminRolePut(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists platform roles available for assignment, including pagination and filters.
         * @summary List system roles (admin)
         * @param {number} page Page number
         * @param {number} [perPage] Page size
         * @param {string} [filter] Text filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminRolesPageGet(page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonRolesPageResponse> {
            return localVarFp.authlanceIdentityApiV1AdminRolesPageGet(page, perPage, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the set of global roles attached to the specified identity.
         * @summary Assign roles to user
         * @param {ControllersUsersRoleAssignmentPayload} payload Identity and roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserRolePut(payload: ControllersUsersRoleAssignmentPayload, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1AdminUserRolePut(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminRolesApi - interface
 * @export
 * @interface AdminRolesApi
 */
export interface AdminRolesApiInterface {
    /**
     * Registers a new platform role that can later be assigned to identities.
     * @summary Create role
     * @param {DunaAuthCommonRoleResponse} payload { name: roleName }
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRolesApiInterface
     */
    authlanceIdentityApiV1AdminRolePut(payload: DunaAuthCommonRoleResponse, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonRoleResponse>;

    /**
     * Lists platform roles available for assignment, including pagination and filters.
     * @summary List system roles (admin)
     * @param {number} page Page number
     * @param {number} [perPage] Page size
     * @param {string} [filter] Text filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRolesApiInterface
     */
    authlanceIdentityApiV1AdminRolesPageGet(page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonRolesPageResponse>;

    /**
     * Replaces the set of global roles attached to the specified identity.
     * @summary Assign roles to user
     * @param {ControllersUsersRoleAssignmentPayload} payload Identity and roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRolesApiInterface
     */
    authlanceIdentityApiV1AdminUserRolePut(payload: ControllersUsersRoleAssignmentPayload, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

}

/**
 * AdminRolesApi - object-oriented interface
 * @export
 * @class AdminRolesApi
 * @extends {BaseAPI}
 */
export class AdminRolesApi extends BaseAPI implements AdminRolesApiInterface {
    /**
     * Registers a new platform role that can later be assigned to identities.
     * @summary Create role
     * @param {DunaAuthCommonRoleResponse} payload { name: roleName }
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRolesApi
     */
    public authlanceIdentityApiV1AdminRolePut(payload: DunaAuthCommonRoleResponse, options?: RawAxiosRequestConfig) {
        return AdminRolesApiFp(this.configuration).authlanceIdentityApiV1AdminRolePut(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists platform roles available for assignment, including pagination and filters.
     * @summary List system roles (admin)
     * @param {number} page Page number
     * @param {number} [perPage] Page size
     * @param {string} [filter] Text filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRolesApi
     */
    public authlanceIdentityApiV1AdminRolesPageGet(page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig) {
        return AdminRolesApiFp(this.configuration).authlanceIdentityApiV1AdminRolesPageGet(page, perPage, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the set of global roles attached to the specified identity.
     * @summary Assign roles to user
     * @param {ControllersUsersRoleAssignmentPayload} payload Identity and roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRolesApi
     */
    public authlanceIdentityApiV1AdminUserRolePut(payload: ControllersUsersRoleAssignmentPayload, options?: RawAxiosRequestConfig) {
        return AdminRolesApiFp(this.configuration).authlanceIdentityApiV1AdminUserRolePut(payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminUsersApi - axios parameter creator
 * @export
 */
export const AdminUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deactivates a user\'s identity and optionally revokes active sessions.
         * @summary Ban user
         * @param {string} identity Identity ID
         * @param {ControllersUsersBanUserRequest} [payload] Ban options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserIdentityBanPost: async (identity: string, payload?: ControllersUsersBanUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminUserIdentityBanPost', 'identity', identity)
            const localVarPath = `/authlance/identity/api/v1/admin/user/{identity}/ban`
                .replace(`{${"identity"}}`, encodeURIComponent(String(identity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a user profile by identity identifier.
         * @summary Find user by identity
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserIdentityGet: async (identity: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminUserIdentityGet', 'identity', identity)
            const localVarPath = `/authlance/identity/api/v1/admin/user/{identity}`
                .replace(`{${"identity"}}`, encodeURIComponent(String(identity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reactivates a previously banned user\'s identity.
         * @summary Unban user
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserIdentityUnbanPost: async (identity: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminUserIdentityUnbanPost', 'identity', identity)
            const localVarPath = `/authlance/identity/api/v1/admin/user/{identity}/unban`
                .replace(`{${"identity"}}`, encodeURIComponent(String(identity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin endpoint to update any user profile. JSON payloads update basic attributes and multipart bodies may include an avatar upload.
         * @summary Update user (admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/identity/api/v1/admin/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user identity and seeds it with the provided global roles.
         * @summary Create user
         * @param {DunaAuthCommonUser} payload User to create (set identityId to -1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserPut: async (payload: DunaAuthCommonUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminUserPut', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/admin/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Paginates over users with optional filter by name or email.
         * @summary List users
         * @param {number} page Page number
         * @param {string} [filter] Filter by name or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUsersPageGet: async (page: number, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminUsersPageGet', 'page', page)
            const localVarPath = `/authlance/identity/api/v1/admin/users/{page}`
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminUsersApi - functional programming interface
 * @export
 */
export const AdminUsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminUsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Deactivates a user\'s identity and optionally revokes active sessions.
         * @summary Ban user
         * @param {string} identity Identity ID
         * @param {ControllersUsersBanUserRequest} [payload] Ban options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminUserIdentityBanPost(identity: string, payload?: ControllersUsersBanUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonIdentityStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminUserIdentityBanPost(identity, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.authlanceIdentityApiV1AdminUserIdentityBanPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a user profile by identity identifier.
         * @summary Find user by identity
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminUserIdentityGet(identity: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminUserIdentityGet(identity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.authlanceIdentityApiV1AdminUserIdentityGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reactivates a previously banned user\'s identity.
         * @summary Unban user
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminUserIdentityUnbanPost(identity: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonIdentityStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminUserIdentityUnbanPost(identity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.authlanceIdentityApiV1AdminUserIdentityUnbanPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admin endpoint to update any user profile. JSON payloads update basic attributes and multipart bodies may include an avatar upload.
         * @summary Update user (admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminUserPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminUserPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.authlanceIdentityApiV1AdminUserPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user identity and seeds it with the provided global roles.
         * @summary Create user
         * @param {DunaAuthCommonUser} payload User to create (set identityId to -1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminUserPut(payload: DunaAuthCommonUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminUserPut(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.authlanceIdentityApiV1AdminUserPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Paginates over users with optional filter by name or email.
         * @summary List users
         * @param {number} page Page number
         * @param {string} [filter] Filter by name or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminUsersPageGet(page: number, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUsersPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminUsersPageGet(page, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.authlanceIdentityApiV1AdminUsersPageGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminUsersApi - factory interface
 * @export
 */
export const AdminUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminUsersApiFp(configuration)
    return {
        /**
         * Deactivates a user\'s identity and optionally revokes active sessions.
         * @summary Ban user
         * @param {string} identity Identity ID
         * @param {ControllersUsersBanUserRequest} [payload] Ban options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserIdentityBanPost(identity: string, payload?: ControllersUsersBanUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonIdentityStateResponse> {
            return localVarFp.authlanceIdentityApiV1AdminUserIdentityBanPost(identity, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a user profile by identity identifier.
         * @summary Find user by identity
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserIdentityGet(identity: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1AdminUserIdentityGet(identity, options).then((request) => request(axios, basePath));
        },
        /**
         * Reactivates a previously banned user\'s identity.
         * @summary Unban user
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserIdentityUnbanPost(identity: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonIdentityStateResponse> {
            return localVarFp.authlanceIdentityApiV1AdminUserIdentityUnbanPost(identity, options).then((request) => request(axios, basePath));
        },
        /**
         * Admin endpoint to update any user profile. JSON payloads update basic attributes and multipart bodies may include an avatar upload.
         * @summary Update user (admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserPost(options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1AdminUserPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user identity and seeds it with the provided global roles.
         * @summary Create user
         * @param {DunaAuthCommonUser} payload User to create (set identityId to -1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserPut(payload: DunaAuthCommonUser, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1AdminUserPut(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Paginates over users with optional filter by name or email.
         * @summary List users
         * @param {number} page Page number
         * @param {string} [filter] Filter by name or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUsersPageGet(page: number, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUsersPageResponse> {
            return localVarFp.authlanceIdentityApiV1AdminUsersPageGet(page, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminUsersApi - interface
 * @export
 * @interface AdminUsersApi
 */
export interface AdminUsersApiInterface {
    /**
     * Deactivates a user\'s identity and optionally revokes active sessions.
     * @summary Ban user
     * @param {string} identity Identity ID
     * @param {ControllersUsersBanUserRequest} [payload] Ban options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApiInterface
     */
    authlanceIdentityApiV1AdminUserIdentityBanPost(identity: string, payload?: ControllersUsersBanUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonIdentityStateResponse>;

    /**
     * Retrieves a user profile by identity identifier.
     * @summary Find user by identity
     * @param {string} identity Identity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApiInterface
     */
    authlanceIdentityApiV1AdminUserIdentityGet(identity: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Reactivates a previously banned user\'s identity.
     * @summary Unban user
     * @param {string} identity Identity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApiInterface
     */
    authlanceIdentityApiV1AdminUserIdentityUnbanPost(identity: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonIdentityStateResponse>;

    /**
     * Admin endpoint to update any user profile. JSON payloads update basic attributes and multipart bodies may include an avatar upload.
     * @summary Update user (admin)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApiInterface
     */
    authlanceIdentityApiV1AdminUserPost(options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Creates a new user identity and seeds it with the provided global roles.
     * @summary Create user
     * @param {DunaAuthCommonUser} payload User to create (set identityId to -1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApiInterface
     */
    authlanceIdentityApiV1AdminUserPut(payload: DunaAuthCommonUser, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Paginates over users with optional filter by name or email.
     * @summary List users
     * @param {number} page Page number
     * @param {string} [filter] Filter by name or email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApiInterface
     */
    authlanceIdentityApiV1AdminUsersPageGet(page: number, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUsersPageResponse>;

}

/**
 * AdminUsersApi - object-oriented interface
 * @export
 * @class AdminUsersApi
 * @extends {BaseAPI}
 */
export class AdminUsersApi extends BaseAPI implements AdminUsersApiInterface {
    /**
     * Deactivates a user\'s identity and optionally revokes active sessions.
     * @summary Ban user
     * @param {string} identity Identity ID
     * @param {ControllersUsersBanUserRequest} [payload] Ban options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public authlanceIdentityApiV1AdminUserIdentityBanPost(identity: string, payload?: ControllersUsersBanUserRequest, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).authlanceIdentityApiV1AdminUserIdentityBanPost(identity, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a user profile by identity identifier.
     * @summary Find user by identity
     * @param {string} identity Identity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public authlanceIdentityApiV1AdminUserIdentityGet(identity: string, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).authlanceIdentityApiV1AdminUserIdentityGet(identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reactivates a previously banned user\'s identity.
     * @summary Unban user
     * @param {string} identity Identity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public authlanceIdentityApiV1AdminUserIdentityUnbanPost(identity: string, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).authlanceIdentityApiV1AdminUserIdentityUnbanPost(identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admin endpoint to update any user profile. JSON payloads update basic attributes and multipart bodies may include an avatar upload.
     * @summary Update user (admin)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public authlanceIdentityApiV1AdminUserPost(options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).authlanceIdentityApiV1AdminUserPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user identity and seeds it with the provided global roles.
     * @summary Create user
     * @param {DunaAuthCommonUser} payload User to create (set identityId to -1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public authlanceIdentityApiV1AdminUserPut(payload: DunaAuthCommonUser, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).authlanceIdentityApiV1AdminUserPut(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Paginates over users with optional filter by name or email.
     * @summary List users
     * @param {number} page Page number
     * @param {string} [filter] Filter by name or email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public authlanceIdentityApiV1AdminUsersPageGet(page: number, filter?: string, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).authlanceIdentityApiV1AdminUsersPageGet(page, filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Clears the authentication cookie to log out the user.
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityMeLogoutGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/identity/me/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts a `session` ID and returns a signed JWT used for the protected API.
         * @summary Exchange a session for JWT
         * @param {ControllersAuthAuthRequest} payload Authentication payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityMePost: async (payload: ControllersAuthAuthRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityMePost', 'payload', payload)
            const localVarPath = `/authlance/identity/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Clears the authentication cookie to log out the user.
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityMeLogoutGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersAuthLogoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityMeLogoutGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authlanceIdentityMeLogoutGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Accepts a `session` ID and returns a signed JWT used for the protected API.
         * @summary Exchange a session for JWT
         * @param {ControllersAuthAuthRequest} payload Authentication payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityMePost(payload: ControllersAuthAuthRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersAuthAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityMePost(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authlanceIdentityMePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Clears the authentication cookie to log out the user.
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityMeLogoutGet(options?: RawAxiosRequestConfig): AxiosPromise<ControllersAuthLogoutResponse> {
            return localVarFp.authlanceIdentityMeLogoutGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts a `session` ID and returns a signed JWT used for the protected API.
         * @summary Exchange a session for JWT
         * @param {ControllersAuthAuthRequest} payload Authentication payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityMePost(payload: ControllersAuthAuthRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersAuthAuthResponse> {
            return localVarFp.authlanceIdentityMePost(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * Clears the authentication cookie to log out the user.
     * @summary Logout user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authlanceIdentityMeLogoutGet(options?: RawAxiosRequestConfig): AxiosPromise<ControllersAuthLogoutResponse>;

    /**
     * Accepts a `session` ID and returns a signed JWT used for the protected API.
     * @summary Exchange a session for JWT
     * @param {ControllersAuthAuthRequest} payload Authentication payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authlanceIdentityMePost(payload: ControllersAuthAuthRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersAuthAuthResponse>;

}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * Clears the authentication cookie to log out the user.
     * @summary Logout user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authlanceIdentityMeLogoutGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authlanceIdentityMeLogoutGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts a `session` ID and returns a signed JWT used for the protected API.
     * @summary Exchange a session for JWT
     * @param {ControllersAuthAuthRequest} payload Authentication payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authlanceIdentityMePost(payload: ControllersAuthAuthRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authlanceIdentityMePost(payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LicenseApi - axios parameter creator
 * @export
 */
export const LicenseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Forces the license manager to reload the license file immediately (requires sysadmin privileges).
         * @summary Reload license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminLicenseReloadPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/identity/api/v1/admin/license/reload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current evaluated license status (requires sysadmin privileges).
         * @summary Get license status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminLicenseStatusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/identity/api/v1/admin/license/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Persists a new license payload and reloads the active license status (requires sysadmin privileges).
         * @summary Update license
         * @param {ControllersLicenseUpdateLicenseRequest} payload License payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminLicenseValuePut: async (payload: ControllersLicenseUpdateLicenseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminLicenseValuePut', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/admin/license/value`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LicenseApi - functional programming interface
 * @export
 */
export const LicenseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LicenseApiAxiosParamCreator(configuration)
    return {
        /**
         * Forces the license manager to reload the license file immediately (requires sysadmin privileges).
         * @summary Reload license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminLicenseReloadPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersLicenseLicenseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminLicenseReloadPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseApi.authlanceIdentityApiV1AdminLicenseReloadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the current evaluated license status (requires sysadmin privileges).
         * @summary Get license status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminLicenseStatusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersLicenseLicenseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminLicenseStatusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseApi.authlanceIdentityApiV1AdminLicenseStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Persists a new license payload and reloads the active license status (requires sysadmin privileges).
         * @summary Update license
         * @param {ControllersLicenseUpdateLicenseRequest} payload License payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminLicenseValuePut(payload: ControllersLicenseUpdateLicenseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersLicenseLicenseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminLicenseValuePut(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseApi.authlanceIdentityApiV1AdminLicenseValuePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LicenseApi - factory interface
 * @export
 */
export const LicenseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LicenseApiFp(configuration)
    return {
        /**
         * Forces the license manager to reload the license file immediately (requires sysadmin privileges).
         * @summary Reload license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminLicenseReloadPost(options?: RawAxiosRequestConfig): AxiosPromise<ControllersLicenseLicenseStatusResponse> {
            return localVarFp.authlanceIdentityApiV1AdminLicenseReloadPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current evaluated license status (requires sysadmin privileges).
         * @summary Get license status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminLicenseStatusGet(options?: RawAxiosRequestConfig): AxiosPromise<ControllersLicenseLicenseStatusResponse> {
            return localVarFp.authlanceIdentityApiV1AdminLicenseStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Persists a new license payload and reloads the active license status (requires sysadmin privileges).
         * @summary Update license
         * @param {ControllersLicenseUpdateLicenseRequest} payload License payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminLicenseValuePut(payload: ControllersLicenseUpdateLicenseRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersLicenseLicenseStatusResponse> {
            return localVarFp.authlanceIdentityApiV1AdminLicenseValuePut(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LicenseApi - interface
 * @export
 * @interface LicenseApi
 */
export interface LicenseApiInterface {
    /**
     * Forces the license manager to reload the license file immediately (requires sysadmin privileges).
     * @summary Reload license
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApiInterface
     */
    authlanceIdentityApiV1AdminLicenseReloadPost(options?: RawAxiosRequestConfig): AxiosPromise<ControllersLicenseLicenseStatusResponse>;

    /**
     * Returns the current evaluated license status (requires sysadmin privileges).
     * @summary Get license status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApiInterface
     */
    authlanceIdentityApiV1AdminLicenseStatusGet(options?: RawAxiosRequestConfig): AxiosPromise<ControllersLicenseLicenseStatusResponse>;

    /**
     * Persists a new license payload and reloads the active license status (requires sysadmin privileges).
     * @summary Update license
     * @param {ControllersLicenseUpdateLicenseRequest} payload License payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApiInterface
     */
    authlanceIdentityApiV1AdminLicenseValuePut(payload: ControllersLicenseUpdateLicenseRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersLicenseLicenseStatusResponse>;

}

/**
 * LicenseApi - object-oriented interface
 * @export
 * @class LicenseApi
 * @extends {BaseAPI}
 */
export class LicenseApi extends BaseAPI implements LicenseApiInterface {
    /**
     * Forces the license manager to reload the license file immediately (requires sysadmin privileges).
     * @summary Reload license
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public authlanceIdentityApiV1AdminLicenseReloadPost(options?: RawAxiosRequestConfig) {
        return LicenseApiFp(this.configuration).authlanceIdentityApiV1AdminLicenseReloadPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current evaluated license status (requires sysadmin privileges).
     * @summary Get license status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public authlanceIdentityApiV1AdminLicenseStatusGet(options?: RawAxiosRequestConfig) {
        return LicenseApiFp(this.configuration).authlanceIdentityApiV1AdminLicenseStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Persists a new license payload and reloads the active license status (requires sysadmin privileges).
     * @summary Update license
     * @param {ControllersLicenseUpdateLicenseRequest} payload License payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public authlanceIdentityApiV1AdminLicenseValuePut(payload: ControllersLicenseUpdateLicenseRequest, options?: RawAxiosRequestConfig) {
        return LicenseApiFp(this.configuration).authlanceIdentityApiV1AdminLicenseValuePut(payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Stripe checkout session for subscription payment
         * @summary Create checkout session
         * @param {DunaAuthCommonCreateCheckoutSessionRequest} request Checkout session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1CheckoutSessionPost: async (request: DunaAuthCommonCreateCheckoutSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authlancePaymentsApiV1CheckoutSessionPost', 'request', request)
            const localVarPath = `/authlance/payments/api/v1/checkout-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Stripe customer portal session for subscription management
         * @summary Create customer portal session
         * @param {DunaAuthCommonCreateCustomerPortalSessionRequest} request Portal session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1CustomerPortalPost: async (request: DunaAuthCommonCreateCustomerPortalSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authlancePaymentsApiV1CustomerPortalPost', 'request', request)
            const localVarPath = `/authlance/payments/api/v1/customer-portal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves Stripe product details by lookup key
         * @summary Get product details
         * @param {DunaAuthCommonGetProductDetailsRequest} request Product details request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1ProductDetailsPost: async (request: DunaAuthCommonGetProductDetailsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authlancePaymentsApiV1ProductDetailsPost', 'request', request)
            const localVarPath = `/authlance/payments/api/v1/product-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the subscription ID from a checkout session
         * @summary Get subscription from session
         * @param {DunaAuthCommonGetSubscriptionSessionRequest} request Session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1SessionIdPost: async (request: DunaAuthCommonGetSubscriptionSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authlancePaymentsApiV1SessionIdPost', 'request', request)
            const localVarPath = `/authlance/payments/api/v1/session-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Processes Stripe webhook events
         * @summary Handle Stripe webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1StripeWebhookPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/payments/api/v1/stripe/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new Stripe checkout session for subscription payment
         * @summary Create checkout session
         * @param {DunaAuthCommonCreateCheckoutSessionRequest} request Checkout session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlancePaymentsApiV1CheckoutSessionPost(request: DunaAuthCommonCreateCheckoutSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonCreateCheckoutSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlancePaymentsApiV1CheckoutSessionPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.authlancePaymentsApiV1CheckoutSessionPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Stripe customer portal session for subscription management
         * @summary Create customer portal session
         * @param {DunaAuthCommonCreateCustomerPortalSessionRequest} request Portal session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlancePaymentsApiV1CustomerPortalPost(request: DunaAuthCommonCreateCustomerPortalSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonCreateCustomerPortalSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlancePaymentsApiV1CustomerPortalPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.authlancePaymentsApiV1CustomerPortalPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves Stripe product details by lookup key
         * @summary Get product details
         * @param {DunaAuthCommonGetProductDetailsRequest} request Product details request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlancePaymentsApiV1ProductDetailsPost(request: DunaAuthCommonGetProductDetailsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGetProductDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlancePaymentsApiV1ProductDetailsPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.authlancePaymentsApiV1ProductDetailsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the subscription ID from a checkout session
         * @summary Get subscription from session
         * @param {DunaAuthCommonGetSubscriptionSessionRequest} request Session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlancePaymentsApiV1SessionIdPost(request: DunaAuthCommonGetSubscriptionSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGetSubscriptionSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlancePaymentsApiV1SessionIdPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.authlancePaymentsApiV1SessionIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Processes Stripe webhook events
         * @summary Handle Stripe webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlancePaymentsApiV1StripeWebhookPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlancePaymentsApiV1StripeWebhookPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.authlancePaymentsApiV1StripeWebhookPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * Creates a new Stripe checkout session for subscription payment
         * @summary Create checkout session
         * @param {DunaAuthCommonCreateCheckoutSessionRequest} request Checkout session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1CheckoutSessionPost(request: DunaAuthCommonCreateCheckoutSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonCreateCheckoutSessionResponse> {
            return localVarFp.authlancePaymentsApiV1CheckoutSessionPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Stripe customer portal session for subscription management
         * @summary Create customer portal session
         * @param {DunaAuthCommonCreateCustomerPortalSessionRequest} request Portal session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1CustomerPortalPost(request: DunaAuthCommonCreateCustomerPortalSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonCreateCustomerPortalSessionResponse> {
            return localVarFp.authlancePaymentsApiV1CustomerPortalPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves Stripe product details by lookup key
         * @summary Get product details
         * @param {DunaAuthCommonGetProductDetailsRequest} request Product details request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1ProductDetailsPost(request: DunaAuthCommonGetProductDetailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGetProductDetailsResponse> {
            return localVarFp.authlancePaymentsApiV1ProductDetailsPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the subscription ID from a checkout session
         * @summary Get subscription from session
         * @param {DunaAuthCommonGetSubscriptionSessionRequest} request Session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1SessionIdPost(request: DunaAuthCommonGetSubscriptionSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGetSubscriptionSessionResponse> {
            return localVarFp.authlancePaymentsApiV1SessionIdPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Processes Stripe webhook events
         * @summary Handle Stripe webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1StripeWebhookPost(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.authlancePaymentsApiV1StripeWebhookPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - interface
 * @export
 * @interface PaymentsApi
 */
export interface PaymentsApiInterface {
    /**
     * Creates a new Stripe checkout session for subscription payment
     * @summary Create checkout session
     * @param {DunaAuthCommonCreateCheckoutSessionRequest} request Checkout session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApiInterface
     */
    authlancePaymentsApiV1CheckoutSessionPost(request: DunaAuthCommonCreateCheckoutSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonCreateCheckoutSessionResponse>;

    /**
     * Creates a Stripe customer portal session for subscription management
     * @summary Create customer portal session
     * @param {DunaAuthCommonCreateCustomerPortalSessionRequest} request Portal session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApiInterface
     */
    authlancePaymentsApiV1CustomerPortalPost(request: DunaAuthCommonCreateCustomerPortalSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonCreateCustomerPortalSessionResponse>;

    /**
     * Retrieves Stripe product details by lookup key
     * @summary Get product details
     * @param {DunaAuthCommonGetProductDetailsRequest} request Product details request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApiInterface
     */
    authlancePaymentsApiV1ProductDetailsPost(request: DunaAuthCommonGetProductDetailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGetProductDetailsResponse>;

    /**
     * Retrieves the subscription ID from a checkout session
     * @summary Get subscription from session
     * @param {DunaAuthCommonGetSubscriptionSessionRequest} request Session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApiInterface
     */
    authlancePaymentsApiV1SessionIdPost(request: DunaAuthCommonGetSubscriptionSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGetSubscriptionSessionResponse>;

    /**
     * Processes Stripe webhook events
     * @summary Handle Stripe webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApiInterface
     */
    authlancePaymentsApiV1StripeWebhookPost(options?: RawAxiosRequestConfig): AxiosPromise<string>;

}

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI implements PaymentsApiInterface {
    /**
     * Creates a new Stripe checkout session for subscription payment
     * @summary Create checkout session
     * @param {DunaAuthCommonCreateCheckoutSessionRequest} request Checkout session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public authlancePaymentsApiV1CheckoutSessionPost(request: DunaAuthCommonCreateCheckoutSessionRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).authlancePaymentsApiV1CheckoutSessionPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Stripe customer portal session for subscription management
     * @summary Create customer portal session
     * @param {DunaAuthCommonCreateCustomerPortalSessionRequest} request Portal session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public authlancePaymentsApiV1CustomerPortalPost(request: DunaAuthCommonCreateCustomerPortalSessionRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).authlancePaymentsApiV1CustomerPortalPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves Stripe product details by lookup key
     * @summary Get product details
     * @param {DunaAuthCommonGetProductDetailsRequest} request Product details request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public authlancePaymentsApiV1ProductDetailsPost(request: DunaAuthCommonGetProductDetailsRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).authlancePaymentsApiV1ProductDetailsPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the subscription ID from a checkout session
     * @summary Get subscription from session
     * @param {DunaAuthCommonGetSubscriptionSessionRequest} request Session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public authlancePaymentsApiV1SessionIdPost(request: DunaAuthCommonGetSubscriptionSessionRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).authlancePaymentsApiV1SessionIdPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Processes Stripe webhook events
     * @summary Handle Stripe webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public authlancePaymentsApiV1StripeWebhookPost(options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).authlancePaymentsApiV1StripeWebhookPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PersonalAccessTokensApi - axios parameter creator
 * @export
 */
export const PersonalAccessTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists personal access tokens for the specified group.
         * @summary List personal access tokens for a group
         * @param {number} groupId Group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1PatsGet: async (groupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1PatsGet', 'groupId', groupId)
            const localVarPath = `/authlance/identity/api/v1/pats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new personal access token for a group and returns the token value once.
         * @summary Create personal access token
         * @param {ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest} payload Personal access token payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1PatsPost: async (payload: ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1PatsPost', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/pats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revokes a personal access token by setting its revokedAt timestamp.
         * @summary Revoke personal access token
         * @param {string} tokenId Token identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1PatsTokenIdDelete: async (tokenId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1PatsTokenIdDelete', 'tokenId', tokenId)
            const localVarPath = `/authlance/identity/api/v1/pats/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies whether a personal access token is valid and returns its metadata.
         * @summary Verify personal access token
         * @param {string} [authorization] Bearer pat_&lt;prefix&gt;-&lt;secret&gt;
         * @param {ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest} [payload] Verification payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1PatsVerifyPost: async (authorization?: string, payload?: ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/identity/api/v1/pats/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonalAccessTokensApi - functional programming interface
 * @export
 */
export const PersonalAccessTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonalAccessTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists personal access tokens for the specified group.
         * @summary List personal access tokens for a group
         * @param {number} groupId Group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1PatsGet(groupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ControllersPersonalaccesstokensPersonalAccessTokenResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1PatsGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonalAccessTokensApi.authlanceIdentityApiV1PatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new personal access token for a group and returns the token value once.
         * @summary Create personal access token
         * @param {ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest} payload Personal access token payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1PatsPost(payload: ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersPersonalaccesstokensPersonalAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1PatsPost(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonalAccessTokensApi.authlanceIdentityApiV1PatsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revokes a personal access token by setting its revokedAt timestamp.
         * @summary Revoke personal access token
         * @param {string} tokenId Token identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1PatsTokenIdDelete(tokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1PatsTokenIdDelete(tokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonalAccessTokensApi.authlanceIdentityApiV1PatsTokenIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies whether a personal access token is valid and returns its metadata.
         * @summary Verify personal access token
         * @param {string} [authorization] Bearer pat_&lt;prefix&gt;-&lt;secret&gt;
         * @param {ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest} [payload] Verification payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1PatsVerifyPost(authorization?: string, payload?: ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1PatsVerifyPost(authorization, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonalAccessTokensApi.authlanceIdentityApiV1PatsVerifyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PersonalAccessTokensApi - factory interface
 * @export
 */
export const PersonalAccessTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonalAccessTokensApiFp(configuration)
    return {
        /**
         * Lists personal access tokens for the specified group.
         * @summary List personal access tokens for a group
         * @param {number} groupId Group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1PatsGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ControllersPersonalaccesstokensPersonalAccessTokenResponse>> {
            return localVarFp.authlanceIdentityApiV1PatsGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new personal access token for a group and returns the token value once.
         * @summary Create personal access token
         * @param {ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest} payload Personal access token payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1PatsPost(payload: ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersPersonalaccesstokensPersonalAccessTokenResponse> {
            return localVarFp.authlanceIdentityApiV1PatsPost(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Revokes a personal access token by setting its revokedAt timestamp.
         * @summary Revoke personal access token
         * @param {string} tokenId Token identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1PatsTokenIdDelete(tokenId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authlanceIdentityApiV1PatsTokenIdDelete(tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies whether a personal access token is valid and returns its metadata.
         * @summary Verify personal access token
         * @param {string} [authorization] Bearer pat_&lt;prefix&gt;-&lt;secret&gt;
         * @param {ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest} [payload] Verification payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1PatsVerifyPost(authorization?: string, payload?: ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse> {
            return localVarFp.authlanceIdentityApiV1PatsVerifyPost(authorization, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonalAccessTokensApi - interface
 * @export
 * @interface PersonalAccessTokensApi
 */
export interface PersonalAccessTokensApiInterface {
    /**
     * Lists personal access tokens for the specified group.
     * @summary List personal access tokens for a group
     * @param {number} groupId Group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApiInterface
     */
    authlanceIdentityApiV1PatsGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ControllersPersonalaccesstokensPersonalAccessTokenResponse>>;

    /**
     * Creates a new personal access token for a group and returns the token value once.
     * @summary Create personal access token
     * @param {ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest} payload Personal access token payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApiInterface
     */
    authlanceIdentityApiV1PatsPost(payload: ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersPersonalaccesstokensPersonalAccessTokenResponse>;

    /**
     * Revokes a personal access token by setting its revokedAt timestamp.
     * @summary Revoke personal access token
     * @param {string} tokenId Token identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApiInterface
     */
    authlanceIdentityApiV1PatsTokenIdDelete(tokenId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Verifies whether a personal access token is valid and returns its metadata.
     * @summary Verify personal access token
     * @param {string} [authorization] Bearer pat_&lt;prefix&gt;-&lt;secret&gt;
     * @param {ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest} [payload] Verification payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApiInterface
     */
    authlanceIdentityApiV1PatsVerifyPost(authorization?: string, payload?: ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse>;

}

/**
 * PersonalAccessTokensApi - object-oriented interface
 * @export
 * @class PersonalAccessTokensApi
 * @extends {BaseAPI}
 */
export class PersonalAccessTokensApi extends BaseAPI implements PersonalAccessTokensApiInterface {
    /**
     * Lists personal access tokens for the specified group.
     * @summary List personal access tokens for a group
     * @param {number} groupId Group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public authlanceIdentityApiV1PatsGet(groupId: number, options?: RawAxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).authlanceIdentityApiV1PatsGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new personal access token for a group and returns the token value once.
     * @summary Create personal access token
     * @param {ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest} payload Personal access token payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public authlanceIdentityApiV1PatsPost(payload: ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest, options?: RawAxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).authlanceIdentityApiV1PatsPost(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revokes a personal access token by setting its revokedAt timestamp.
     * @summary Revoke personal access token
     * @param {string} tokenId Token identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public authlanceIdentityApiV1PatsTokenIdDelete(tokenId: string, options?: RawAxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).authlanceIdentityApiV1PatsTokenIdDelete(tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies whether a personal access token is valid and returns its metadata.
     * @summary Verify personal access token
     * @param {string} [authorization] Bearer pat_&lt;prefix&gt;-&lt;secret&gt;
     * @param {ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest} [payload] Verification payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public authlanceIdentityApiV1PatsVerifyPost(authorization?: string, payload?: ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest, options?: RawAxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).authlanceIdentityApiV1PatsVerifyPost(authorization, payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Updates the authenticated user\'s profile. JSON payloads update the basic attributes and multipart bodies may include an avatar upload.
         * @summary Update current profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileMePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/identity/api/v1/profile/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies if a group slug is free before the authenticated user attempts to create or join it.
         * @summary Check if a group name is available
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet: async (group: string, user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet', 'group', group)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet', 'user', user)
            const localVarPath = `/authlance/identity/api/v1/profile/my-group/{group}/{user}/available`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paginated platform roles that the authenticated user can request within their groups.
         * @summary List available roles for current context
         * @param {string} user User identity
         * @param {number} page Page number
         * @param {number} [perPage] Page size
         * @param {string} [filter] Text filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet: async (user: string, page: number, perPage?: number, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet', 'user', user)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet', 'page', page)
            const localVarPath = `/authlance/identity/api/v1/profile/my-group/roles/{user}/{page}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns every group that belongs to the authenticated identity. The `{user}` parameter is kept for compatibility and is ignored.
         * @summary List authenticated user\'s groups
         * @param {string} user Compatibility placeholder (use \&#39;me\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileMyGroupsUserGet: async (user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileMyGroupsUserGet', 'user', user)
            const localVarPath = `/authlance/identity/api/v1/profile/my-groups/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * Updates the authenticated user\'s profile. JSON payloads update the basic attributes and multipart bodies may include an avatar upload.
         * @summary Update current profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1ProfileMePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1ProfileMePost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.authlanceIdentityApiV1ProfileMePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies if a group slug is free before the authenticated user attempts to create or join it.
         * @summary Check if a group name is available
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet(group: string, user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupAvailabilityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet(group, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns paginated platform roles that the authenticated user can request within their groups.
         * @summary List available roles for current context
         * @param {string} user User identity
         * @param {number} page Page number
         * @param {number} [perPage] Page size
         * @param {string} [filter] Text filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet(user: string, page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonRolesPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet(user, page, perPage, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns every group that belongs to the authenticated identity. The `{user}` parameter is kept for compatibility and is ignored.
         * @summary List authenticated user\'s groups
         * @param {string} user Compatibility placeholder (use \&#39;me\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1ProfileMyGroupsUserGet(user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DunaAuthCommonGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1ProfileMyGroupsUserGet(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.authlanceIdentityApiV1ProfileMyGroupsUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * Updates the authenticated user\'s profile. JSON payloads update the basic attributes and multipart bodies may include an avatar upload.
         * @summary Update current profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileMePost(options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1ProfileMePost(options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies if a group slug is free before the authenticated user attempts to create or join it.
         * @summary Check if a group name is available
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet(group: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupAvailabilityResponse> {
            return localVarFp.authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet(group, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns paginated platform roles that the authenticated user can request within their groups.
         * @summary List available roles for current context
         * @param {string} user User identity
         * @param {number} page Page number
         * @param {number} [perPage] Page size
         * @param {string} [filter] Text filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet(user: string, page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonRolesPageResponse> {
            return localVarFp.authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet(user, page, perPage, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns every group that belongs to the authenticated identity. The `{user}` parameter is kept for compatibility and is ignored.
         * @summary List authenticated user\'s groups
         * @param {string} user Compatibility placeholder (use \&#39;me\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileMyGroupsUserGet(user: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonGroup>> {
            return localVarFp.authlanceIdentityApiV1ProfileMyGroupsUserGet(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - interface
 * @export
 * @interface ProfileApi
 */
export interface ProfileApiInterface {
    /**
     * Updates the authenticated user\'s profile. JSON payloads update the basic attributes and multipart bodies may include an avatar upload.
     * @summary Update current profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApiInterface
     */
    authlanceIdentityApiV1ProfileMePost(options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Verifies if a group slug is free before the authenticated user attempts to create or join it.
     * @summary Check if a group name is available
     * @param {string} group Group name
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApiInterface
     */
    authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet(group: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupAvailabilityResponse>;

    /**
     * Returns paginated platform roles that the authenticated user can request within their groups.
     * @summary List available roles for current context
     * @param {string} user User identity
     * @param {number} page Page number
     * @param {number} [perPage] Page size
     * @param {string} [filter] Text filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApiInterface
     */
    authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet(user: string, page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonRolesPageResponse>;

    /**
     * Returns every group that belongs to the authenticated identity. The `{user}` parameter is kept for compatibility and is ignored.
     * @summary List authenticated user\'s groups
     * @param {string} user Compatibility placeholder (use \&#39;me\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApiInterface
     */
    authlanceIdentityApiV1ProfileMyGroupsUserGet(user: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonGroup>>;

}

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI implements ProfileApiInterface {
    /**
     * Updates the authenticated user\'s profile. JSON payloads update the basic attributes and multipart bodies may include an avatar upload.
     * @summary Update current profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public authlanceIdentityApiV1ProfileMePost(options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).authlanceIdentityApiV1ProfileMePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies if a group slug is free before the authenticated user attempts to create or join it.
     * @summary Check if a group name is available
     * @param {string} group Group name
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet(group: string, user: string, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet(group, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns paginated platform roles that the authenticated user can request within their groups.
     * @summary List available roles for current context
     * @param {string} user User identity
     * @param {number} page Page number
     * @param {number} [perPage] Page size
     * @param {string} [filter] Text filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet(user: string, page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet(user, page, perPage, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns every group that belongs to the authenticated identity. The `{user}` parameter is kept for compatibility and is ignored.
     * @summary List authenticated user\'s groups
     * @param {string} user Compatibility placeholder (use \&#39;me\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public authlanceIdentityApiV1ProfileMyGroupsUserGet(user: string, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).authlanceIdentityApiV1ProfileMyGroupsUserGet(user, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RealmAdminGroupsApi - axios parameter creator
 * @export
 */
export const RealmAdminGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Realm-level admin endpoint to remove a user from the target group.
         * @summary Remove user from group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/realm/admin/group/{group}/members`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Realm-level admin endpoint to add or invite a user to the target group.
         * @summary Add user to group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupGroupMembersPost: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupGroupMembersPost', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/realm/admin/group/{group}/members`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Realm-level admin endpoint to manage roles assigned to a group member.
         * @summary Assign roles to group member (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupGroupRolePost: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupGroupRolePost', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/realm/admin/group/{group}/role`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Realm-level admin endpoint that returns the roles granted to the specified user inside the given group.
         * @summary Get a member\'s roles in a group (realm admin)
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet: async (group: string, user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet', 'group', group)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet', 'user', user)
            const localVarPath = `/authlance/identity/api/v1/realm/admin/group/{group}/role/{user}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Realm-level admin endpoint that lists every member in the group with their roles.
         * @summary List roles assigned within a group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupRolesGroupGet: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupRolesGroupGet', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/realm/admin/group/roles/{group}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RealmAdminGroupsApi - functional programming interface
 * @export
 */
export const RealmAdminGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RealmAdminGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Realm-level admin endpoint to remove a user from the target group.
         * @summary Remove user from group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmAdminGroupsApi.authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Realm-level admin endpoint to add or invite a user to the target group.
         * @summary Add user to group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmAdminGroupGroupMembersPost(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmAdminGroupGroupMembersPost(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmAdminGroupsApi.authlanceIdentityApiV1RealmAdminGroupGroupMembersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Realm-level admin endpoint to manage roles assigned to a group member.
         * @summary Assign roles to group member (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmAdminGroupGroupRolePost(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmAdminGroupGroupRolePost(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmAdminGroupsApi.authlanceIdentityApiV1RealmAdminGroupGroupRolePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Realm-level admin endpoint that returns the roles granted to the specified user inside the given group.
         * @summary Get a member\'s roles in a group (realm admin)
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupMemberRolesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet(group, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmAdminGroupsApi.authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Realm-level admin endpoint that lists every member in the group with their roles.
         * @summary List roles assigned within a group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmAdminGroupRolesGroupGet(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupMembershipRolesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmAdminGroupRolesGroupGet(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmAdminGroupsApi.authlanceIdentityApiV1RealmAdminGroupRolesGroupGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RealmAdminGroupsApi - factory interface
 * @export
 */
export const RealmAdminGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RealmAdminGroupsApiFp(configuration)
    return {
        /**
         * Realm-level admin endpoint to remove a user from the target group.
         * @summary Remove user from group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Realm-level admin endpoint to add or invite a user to the target group.
         * @summary Add user to group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupGroupMembersPost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1RealmAdminGroupGroupMembersPost(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Realm-level admin endpoint to manage roles assigned to a group member.
         * @summary Assign roles to group member (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupGroupRolePost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1RealmAdminGroupGroupRolePost(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Realm-level admin endpoint that returns the roles granted to the specified user inside the given group.
         * @summary Get a member\'s roles in a group (realm admin)
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMemberRolesResponse> {
            return localVarFp.authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet(group, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Realm-level admin endpoint that lists every member in the group with their roles.
         * @summary List roles assigned within a group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupRolesGroupGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMembershipRolesListResponse> {
            return localVarFp.authlanceIdentityApiV1RealmAdminGroupRolesGroupGet(group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RealmAdminGroupsApi - interface
 * @export
 * @interface RealmAdminGroupsApi
 */
export interface RealmAdminGroupsApiInterface {
    /**
     * Realm-level admin endpoint to remove a user from the target group.
     * @summary Remove user from group (realm admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApiInterface
     */
    authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Realm-level admin endpoint to add or invite a user to the target group.
     * @summary Add user to group (realm admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApiInterface
     */
    authlanceIdentityApiV1RealmAdminGroupGroupMembersPost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Realm-level admin endpoint to manage roles assigned to a group member.
     * @summary Assign roles to group member (realm admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApiInterface
     */
    authlanceIdentityApiV1RealmAdminGroupGroupRolePost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Realm-level admin endpoint that returns the roles granted to the specified user inside the given group.
     * @summary Get a member\'s roles in a group (realm admin)
     * @param {string} group Group name
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApiInterface
     */
    authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMemberRolesResponse>;

    /**
     * Realm-level admin endpoint that lists every member in the group with their roles.
     * @summary List roles assigned within a group (realm admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApiInterface
     */
    authlanceIdentityApiV1RealmAdminGroupRolesGroupGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMembershipRolesListResponse>;

}

/**
 * RealmAdminGroupsApi - object-oriented interface
 * @export
 * @class RealmAdminGroupsApi
 * @extends {BaseAPI}
 */
export class RealmAdminGroupsApi extends BaseAPI implements RealmAdminGroupsApiInterface {
    /**
     * Realm-level admin endpoint to remove a user from the target group.
     * @summary Remove user from group (realm admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApi
     */
    public authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete(group: string, options?: RawAxiosRequestConfig) {
        return RealmAdminGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Realm-level admin endpoint to add or invite a user to the target group.
     * @summary Add user to group (realm admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApi
     */
    public authlanceIdentityApiV1RealmAdminGroupGroupMembersPost(group: string, options?: RawAxiosRequestConfig) {
        return RealmAdminGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmAdminGroupGroupMembersPost(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Realm-level admin endpoint to manage roles assigned to a group member.
     * @summary Assign roles to group member (realm admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApi
     */
    public authlanceIdentityApiV1RealmAdminGroupGroupRolePost(group: string, options?: RawAxiosRequestConfig) {
        return RealmAdminGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmAdminGroupGroupRolePost(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Realm-level admin endpoint that returns the roles granted to the specified user inside the given group.
     * @summary Get a member\'s roles in a group (realm admin)
     * @param {string} group Group name
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApi
     */
    public authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig) {
        return RealmAdminGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet(group, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Realm-level admin endpoint that lists every member in the group with their roles.
     * @summary List roles assigned within a group (realm admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApi
     */
    public authlanceIdentityApiV1RealmAdminGroupRolesGroupGet(group: string, options?: RawAxiosRequestConfig) {
        return RealmAdminGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmAdminGroupRolesGroupGet(group, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RealmGroupsApi - axios parameter creator
 * @export
 */
export const RealmGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns public details for the specified group within the caller\'s realm.
         * @summary Get group
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupGroupGet: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupGroupGet', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/realm/group/{group}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the users that belong to the given group inside the caller\'s realm.
         * @summary List group members
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupGroupMembersGet: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupGroupMembersGet', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/realm/group/{group}/members`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates group metadata that is accessible within the current realm.
         * @summary Update group
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupGroupPost: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupGroupPost', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/realm/group/{group}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the roles granted to the specified user inside the given group within the caller\'s realm.
         * @summary Get a member\'s roles in a group
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupGroupRoleUserGet: async (group: string, user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupGroupRoleUserGet', 'group', group)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupGroupRoleUserGet', 'user', user)
            const localVarPath = `/authlance/identity/api/v1/realm/group/{group}/role/{user}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RealmGroupsApi - functional programming interface
 * @export
 */
export const RealmGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RealmGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns public details for the specified group within the caller\'s realm.
         * @summary Get group
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupGroupGet(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupGroupGet(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmGroupsApi.authlanceIdentityApiV1RealmGroupGroupGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists the users that belong to the given group inside the caller\'s realm.
         * @summary List group members
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupGroupMembersGet(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DunaAuthCommonUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupGroupMembersGet(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmGroupsApi.authlanceIdentityApiV1RealmGroupGroupMembersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates group metadata that is accessible within the current realm.
         * @summary Update group
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupGroupPost(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupGroupPost(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmGroupsApi.authlanceIdentityApiV1RealmGroupGroupPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the roles granted to the specified user inside the given group within the caller\'s realm.
         * @summary Get a member\'s roles in a group
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupMemberRolesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupGroupRoleUserGet(group, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmGroupsApi.authlanceIdentityApiV1RealmGroupGroupRoleUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RealmGroupsApi - factory interface
 * @export
 */
export const RealmGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RealmGroupsApiFp(configuration)
    return {
        /**
         * Returns public details for the specified group within the caller\'s realm.
         * @summary Get group
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupGroupGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup> {
            return localVarFp.authlanceIdentityApiV1RealmGroupGroupGet(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the users that belong to the given group inside the caller\'s realm.
         * @summary List group members
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupGroupMembersGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonUser>> {
            return localVarFp.authlanceIdentityApiV1RealmGroupGroupMembersGet(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates group metadata that is accessible within the current realm.
         * @summary Update group
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupGroupPost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup> {
            return localVarFp.authlanceIdentityApiV1RealmGroupGroupPost(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the roles granted to the specified user inside the given group within the caller\'s realm.
         * @summary Get a member\'s roles in a group
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMemberRolesResponse> {
            return localVarFp.authlanceIdentityApiV1RealmGroupGroupRoleUserGet(group, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RealmGroupsApi - interface
 * @export
 * @interface RealmGroupsApi
 */
export interface RealmGroupsApiInterface {
    /**
     * Returns public details for the specified group within the caller\'s realm.
     * @summary Get group
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmGroupsApiInterface
     */
    authlanceIdentityApiV1RealmGroupGroupGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup>;

    /**
     * Lists the users that belong to the given group inside the caller\'s realm.
     * @summary List group members
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmGroupsApiInterface
     */
    authlanceIdentityApiV1RealmGroupGroupMembersGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonUser>>;

    /**
     * Updates group metadata that is accessible within the current realm.
     * @summary Update group
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmGroupsApiInterface
     */
    authlanceIdentityApiV1RealmGroupGroupPost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup>;

    /**
     * Returns the roles granted to the specified user inside the given group within the caller\'s realm.
     * @summary Get a member\'s roles in a group
     * @param {string} group Group name
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmGroupsApiInterface
     */
    authlanceIdentityApiV1RealmGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMemberRolesResponse>;

}

/**
 * RealmGroupsApi - object-oriented interface
 * @export
 * @class RealmGroupsApi
 * @extends {BaseAPI}
 */
export class RealmGroupsApi extends BaseAPI implements RealmGroupsApiInterface {
    /**
     * Returns public details for the specified group within the caller\'s realm.
     * @summary Get group
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmGroupsApi
     */
    public authlanceIdentityApiV1RealmGroupGroupGet(group: string, options?: RawAxiosRequestConfig) {
        return RealmGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmGroupGroupGet(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the users that belong to the given group inside the caller\'s realm.
     * @summary List group members
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmGroupsApi
     */
    public authlanceIdentityApiV1RealmGroupGroupMembersGet(group: string, options?: RawAxiosRequestConfig) {
        return RealmGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmGroupGroupMembersGet(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates group metadata that is accessible within the current realm.
     * @summary Update group
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmGroupsApi
     */
    public authlanceIdentityApiV1RealmGroupGroupPost(group: string, options?: RawAxiosRequestConfig) {
        return RealmGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmGroupGroupPost(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the roles granted to the specified user inside the given group within the caller\'s realm.
     * @summary Get a member\'s roles in a group
     * @param {string} group Group name
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmGroupsApi
     */
    public authlanceIdentityApiV1RealmGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig) {
        return RealmGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmGroupGroupRoleUserGet(group, user, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Looks up a group subscription using the external billing subscription ID.
         * @summary Get subscription by billing subscription ID
         * @param {string} user User identity
         * @param {string} billingSubscriptionID Billing subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet: async (user: string, billingSubscriptionID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet', 'user', user)
            // verify required parameter 'billingSubscriptionID' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet', 'billingSubscriptionID', billingSubscriptionID)
            const localVarPath = `/authlance/identity/api/v1/profile/subscriptions/{user}/billing/{billingSubscriptionID}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"billingSubscriptionID"}}`, encodeURIComponent(String(billingSubscriptionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the active subscription for a group. If no active subscription, returns the most recent.
         * @summary Get active or latest subscription for group
         * @param {string} user User identity
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet: async (user: string, group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet', 'user', user)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/profile/subscriptions/{user}/{group}/active`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all available payment tiers.
         * @summary List subscription tiers
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet: async (user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet', 'user', user)
            const localVarPath = `/authlance/identity/api/v1/profile/subscriptions/{user}/tiers`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Looks up a group subscription using the external billing subscription ID.
         * @summary Get subscription by billing subscription ID
         * @param {string} user User identity
         * @param {string} billingSubscriptionID Billing subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet(user: string, billingSubscriptionID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupSubscriptionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet(user, billingSubscriptionID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the active subscription for a group. If no active subscription, returns the most recent.
         * @summary Get active or latest subscription for group
         * @param {string} user User identity
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet(user: string, group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupSubscriptionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet(user, group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all available payment tiers.
         * @summary List subscription tiers
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet(user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DunaAuthCommonPaymentTierDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * Looks up a group subscription using the external billing subscription ID.
         * @summary Get subscription by billing subscription ID
         * @param {string} user User identity
         * @param {string} billingSubscriptionID Billing subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet(user: string, billingSubscriptionID: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupSubscriptionsDto> {
            return localVarFp.authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet(user, billingSubscriptionID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the active subscription for a group. If no active subscription, returns the most recent.
         * @summary Get active or latest subscription for group
         * @param {string} user User identity
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet(user: string, group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupSubscriptionsDto> {
            return localVarFp.authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet(user, group, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all available payment tiers.
         * @summary List subscription tiers
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet(user: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonPaymentTierDto>> {
            return localVarFp.authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionsApi - interface
 * @export
 * @interface SubscriptionsApi
 */
export interface SubscriptionsApiInterface {
    /**
     * Looks up a group subscription using the external billing subscription ID.
     * @summary Get subscription by billing subscription ID
     * @param {string} user User identity
     * @param {string} billingSubscriptionID Billing subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet(user: string, billingSubscriptionID: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupSubscriptionsDto>;

    /**
     * Returns the active subscription for a group. If no active subscription, returns the most recent.
     * @summary Get active or latest subscription for group
     * @param {string} user User identity
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet(user: string, group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupSubscriptionsDto>;

    /**
     * Returns all available payment tiers.
     * @summary List subscription tiers
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet(user: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonPaymentTierDto>>;

}

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI implements SubscriptionsApiInterface {
    /**
     * Looks up a group subscription using the external billing subscription ID.
     * @summary Get subscription by billing subscription ID
     * @param {string} user User identity
     * @param {string} billingSubscriptionID Billing subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet(user: string, billingSubscriptionID: string, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet(user, billingSubscriptionID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the active subscription for a group. If no active subscription, returns the most recent.
     * @summary Get active or latest subscription for group
     * @param {string} user User identity
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet(user: string, group: string, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet(user, group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all available payment tiers.
     * @summary List subscription tiers
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet(user: string, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet(user, options).then((request) => request(this.axios, this.basePath));
    }
}



