/* tslint:disable */
/* eslint-disable */
/**
 * Authlance API
 * Identity, users, groups and subscriptions API for Authlance.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CommonDevicePresence
 */
export interface CommonDevicePresence {
    /**
     * 
     * @type {string}
     * @memberof CommonDevicePresence
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonDevicePresence
     */
    'deviceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonDevicePresence
     */
    'deviceType'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CommonDevicePresence
     */
    'hasPushToken'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CommonDevicePresence
     */
    'lastSeenAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CommonDevicePresence
     */
    'online'?: boolean;
    /**
     * 
     * @type {CommonPushPlatform}
     * @memberof CommonDevicePresence
     */
    'pushPlatform'?: CommonPushPlatform;
    /**
     * 
     * @type {boolean}
     * @memberof CommonDevicePresence
     */
    'reachable'?: boolean;
    /**
     * 
     * @type {CommonPresenceStatus}
     * @memberof CommonDevicePresence
     */
    'status'?: CommonPresenceStatus;
    /**
     * 
     * @type {string}
     * @memberof CommonDevicePresence
     */
    'userId'?: string;
}


/**
 * 
 * @export
 * @interface CommonGroup
 */
export interface CommonGroup {
    /**
     * 
     * @type {string}
     * @memberof CommonGroup
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonGroup
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof CommonGroup
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CommonGroup
     */
    'longName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonGroup
     */
    'name'?: string;
    /**
     * SubscriptionUUID is the App Store account token for the group.
     * @type {string}
     * @memberof CommonGroup
     */
    'subscriptionUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonGroup
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface CommonGroupMemberRole
 */
export interface CommonGroupMemberRole {
    /**
     * 
     * @type {string}
     * @memberof CommonGroupMemberRole
     */
    'group'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonGroupMemberRole
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonGroupMemberRole
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CommonIdentityState = {
    IdentityStateActive: 'active',
    IdentityStateInactive: 'inactive'
} as const;

export type CommonIdentityState = typeof CommonIdentityState[keyof typeof CommonIdentityState];


/**
 * 
 * @export
 * @enum {string}
 */

export const CommonPresenceStatus = {
    PresenceOnline: 'online',
    PresenceReachable: 'reachable',
    PresenceOffline: 'offline'
} as const;

export type CommonPresenceStatus = typeof CommonPresenceStatus[keyof typeof CommonPresenceStatus];


/**
 * 
 * @export
 * @interface CommonPricingTierDto
 */
export interface CommonPricingTierDto {
    /**
     * 
     * @type {number}
     * @memberof CommonPricingTierDto
     */
    'setupPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof CommonPricingTierDto
     */
    'unitPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof CommonPricingTierDto
     */
    'upTo'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CommonPushPlatform = {
    PushPlatformIOS: 'ios',
    PushPlatformAndroid: 'android'
} as const;

export type CommonPushPlatform = typeof CommonPushPlatform[keyof typeof CommonPushPlatform];


/**
 * 
 * @export
 * @interface CommonStripeProductDetails
 */
export interface CommonStripeProductDetails {
    /**
     * 
     * @type {boolean}
     * @memberof CommonStripeProductDetails
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CommonStripeProductDetails
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonStripeProductDetails
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonStripeProductDetails
     */
    'lookup_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonStripeProductDetails
     */
    'nickname'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonStripeProductDetails
     */
    'object'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CommonStripeProductDetails
     */
    'product'?: { [key: string]: any; };
    /**
     * 
     * @type {CommonStripeRecurring}
     * @memberof CommonStripeProductDetails
     */
    'recurring'?: CommonStripeRecurring;
    /**
     * 
     * @type {string}
     * @memberof CommonStripeProductDetails
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof CommonStripeProductDetails
     */
    'unit_amount'?: number;
}
/**
 * 
 * @export
 * @interface CommonStripeRecurring
 */
export interface CommonStripeRecurring {
    /**
     * 
     * @type {string}
     * @memberof CommonStripeRecurring
     */
    'interval'?: string;
    /**
     * 
     * @type {number}
     * @memberof CommonStripeRecurring
     */
    'interval_count'?: number;
}
/**
 * 
 * @export
 * @interface CommonUser
 */
export interface CommonUser {
    /**
     * 
     * @type {string}
     * @memberof CommonUser
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonUser
     */
    'birthDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonUser
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonUser
     */
    'gender'?: string;
    /**
     * 
     * @type {Array<CommonUserGroupRole>}
     * @memberof CommonUser
     */
    'groupRoles'?: Array<CommonUserGroupRole>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CommonUser
     */
    'groups'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CommonUser
     */
    'identity'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonUser
     */
    'lastName'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CommonUser
     */
    'roles'?: Array<string>;
    /**
     * 
     * @type {CommonIdentityState}
     * @memberof CommonUser
     */
    'state'?: CommonIdentityState;
    /**
     * 
     * @type {boolean}
     * @memberof CommonUser
     */
    'verified'?: boolean;
}


/**
 * 
 * @export
 * @interface CommonUserGroupRole
 */
export interface CommonUserGroupRole {
    /**
     * 
     * @type {string}
     * @memberof CommonUserGroupRole
     */
    'group'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommonUserGroupRole
     */
    'role'?: string;
}
/**
 * 
 * @export
 * @interface ControllersAuthAuthRequest
 */
export interface ControllersAuthAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof ControllersAuthAuthRequest
     */
    'session'?: string;
}
/**
 * 
 * @export
 * @interface ControllersAuthAuthResponse
 */
export interface ControllersAuthAuthResponse {
    /**
     * 
     * @type {string}
     * @memberof ControllersAuthAuthResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface ControllersAuthLogoutResponse
 */
export interface ControllersAuthLogoutResponse {
    /**
     * 
     * @type {string}
     * @memberof ControllersAuthLogoutResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ControllersDevicesActivateDeviceRequest
 */
export interface ControllersDevicesActivateDeviceRequest {
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesActivateDeviceRequest
     */
    'encryptedGroupKey'?: string;
}
/**
 * 
 * @export
 * @interface ControllersDevicesCreateKeyRequestRequest
 */
export interface ControllersDevicesCreateKeyRequestRequest {
    /**
     * 
     * @type {number}
     * @memberof ControllersDevicesCreateKeyRequestRequest
     */
    'groupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesCreateKeyRequestRequest
     */
    'requestingDeviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesCreateKeyRequestRequest
     */
    'requestingPublicKey'?: string;
}
/**
 * 
 * @export
 * @interface ControllersDevicesDeviceResponse
 */
export interface ControllersDevicesDeviceResponse {
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesDeviceResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesDeviceResponse
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesDeviceResponse
     */
    'deviceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesDeviceResponse
     */
    'deviceType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesDeviceResponse
     */
    'encryptedGroupKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof ControllersDevicesDeviceResponse
     */
    'groupId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ControllersDevicesDeviceResponse
     */
    'keyVersion'?: number;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesDeviceResponse
     */
    'lastSeenAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesDeviceResponse
     */
    'publicKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesDeviceResponse
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesDeviceResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesDeviceResponse
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface ControllersDevicesGrantKeyRequestRequest
 */
export interface ControllersDevicesGrantKeyRequestRequest {
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesGrantKeyRequestRequest
     */
    'encryptedGroupKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesGrantKeyRequestRequest
     */
    'grantingDeviceId'?: string;
}
/**
 * 
 * @export
 * @interface ControllersDevicesInitializeSecretsRequest
 */
export interface ControllersDevicesInitializeSecretsRequest {
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesInitializeSecretsRequest
     */
    'encryptedPayload'?: string;
}
/**
 * 
 * @export
 * @interface ControllersDevicesKeyRequestResponse
 */
export interface ControllersDevicesKeyRequestResponse {
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesKeyRequestResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesKeyRequestResponse
     */
    'encryptedGroupKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesKeyRequestResponse
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesKeyRequestResponse
     */
    'grantingDeviceId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ControllersDevicesKeyRequestResponse
     */
    'groupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesKeyRequestResponse
     */
    'requestId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesKeyRequestResponse
     */
    'requestingDeviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesKeyRequestResponse
     */
    'requestingPublicKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesKeyRequestResponse
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface ControllersDevicesKeyStatusResponse
 */
export interface ControllersDevicesKeyStatusResponse {
    /**
     * 
     * @type {number}
     * @memberof ControllersDevicesKeyStatusResponse
     */
    'groupId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ControllersDevicesKeyStatusResponse
     */
    'keyReady'?: boolean;
}
/**
 * 
 * @export
 * @interface ControllersDevicesRegisterDeviceRequest
 */
export interface ControllersDevicesRegisterDeviceRequest {
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesRegisterDeviceRequest
     */
    'deviceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesRegisterDeviceRequest
     */
    'deviceType'?: string;
    /**
     * 
     * @type {number}
     * @memberof ControllersDevicesRegisterDeviceRequest
     */
    'groupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesRegisterDeviceRequest
     */
    'publicKey'?: string;
}
/**
 * 
 * @export
 * @interface ControllersDevicesRevokeWithRotationRequest
 */
export interface ControllersDevicesRevokeWithRotationRequest {
    /**
     * 
     * @type {Array<DunaAuthCommonDeviceKeyUpdate>}
     * @memberof ControllersDevicesRevokeWithRotationRequest
     */
    'deviceKeys'?: Array<DunaAuthCommonDeviceKeyUpdate>;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesRevokeWithRotationRequest
     */
    'newEncryptedSecrets'?: string;
}
/**
 * 
 * @export
 * @interface ControllersDevicesRotateKeyRequest
 */
export interface ControllersDevicesRotateKeyRequest {
    /**
     * 
     * @type {Array<DunaAuthCommonDeviceKeyUpdate>}
     * @memberof ControllersDevicesRotateKeyRequest
     */
    'deviceKeys'?: Array<DunaAuthCommonDeviceKeyUpdate>;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesRotateKeyRequest
     */
    'newEncryptedSecrets'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesRotateKeyRequest
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface ControllersDevicesSSEMessage
 */
export interface ControllersDevicesSSEMessage {
    /**
     * 
     * @type {object}
     * @memberof ControllersDevicesSSEMessage
     */
    'data'?: object;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesSSEMessage
     */
    'event'?: string;
}
/**
 * 
 * @export
 * @interface ControllersDevicesSecretsResponse
 */
export interface ControllersDevicesSecretsResponse {
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesSecretsResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesSecretsResponse
     */
    'encryptedPayload'?: string;
    /**
     * 
     * @type {number}
     * @memberof ControllersDevicesSecretsResponse
     */
    'groupId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ControllersDevicesSecretsResponse
     */
    'keyReady'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ControllersDevicesSecretsResponse
     */
    'secretId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesSecretsResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof ControllersDevicesSecretsResponse
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface ControllersDevicesUpdatePublicKeyRequest
 */
export interface ControllersDevicesUpdatePublicKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesUpdatePublicKeyRequest
     */
    'publicKey'?: string;
}
/**
 * 
 * @export
 * @interface ControllersDevicesUpdatePushTokenRequest
 */
export interface ControllersDevicesUpdatePushTokenRequest {
    /**
     * \"ios\" or \"android\"
     * @type {string}
     * @memberof ControllersDevicesUpdatePushTokenRequest
     */
    'platform'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesUpdatePushTokenRequest
     */
    'pushToken'?: string;
}
/**
 * 
 * @export
 * @interface ControllersDevicesUpdateSecretsRequest
 */
export interface ControllersDevicesUpdateSecretsRequest {
    /**
     * 
     * @type {string}
     * @memberof ControllersDevicesUpdateSecretsRequest
     */
    'encryptedPayload'?: string;
    /**
     * 
     * @type {number}
     * @memberof ControllersDevicesUpdateSecretsRequest
     */
    'expectedVersion'?: number;
}
/**
 * 
 * @export
 * @interface ControllersLicenseLicenseStatusResponse
 */
export interface ControllersLicenseLicenseStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof ControllersLicenseLicenseStatusResponse
     */
    'lastError'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersLicenseLicenseStatusResponse
     */
    'state'?: string;
    /**
     * 
     * @type {LicenseStatus}
     * @memberof ControllersLicenseLicenseStatusResponse
     */
    'status'?: LicenseStatus;
    /**
     * 
     * @type {string}
     * @memberof ControllersLicenseLicenseStatusResponse
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface ControllersLicenseUpdateLicenseRequest
 */
export interface ControllersLicenseUpdateLicenseRequest {
    /**
     * 
     * @type {string}
     * @memberof ControllersLicenseUpdateLicenseRequest
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest
 */
export interface ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest {
    /**
     * 
     * @type {number}
     * @memberof ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest
     */
    'expiresInDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest
     */
    'groupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest
     */
    'scopes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ControllersPersonalaccesstokensPersonalAccessTokenResponse
 */
export interface ControllersPersonalaccesstokensPersonalAccessTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'createdAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'displayOnceShown'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'effectiveScope'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'groupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'lastUsedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'revokedAt'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'scopes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'tokenPrefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensPersonalAccessTokenResponse
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest
 */
export interface ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
 */
export interface ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'effectiveScope'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'groupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'lastUsedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'revokedAt'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'scopes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'tokenId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'tokenPrefix'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface ControllersSubscriptionsAppStoreServerNotificationRequest
 */
export interface ControllersSubscriptionsAppStoreServerNotificationRequest {
    /**
     * 
     * @type {string}
     * @memberof ControllersSubscriptionsAppStoreServerNotificationRequest
     */
    'signedPayload'?: string;
}
/**
 * 
 * @export
 * @interface ControllersSubscriptionsAppStoreVerifyRequest
 */
export interface ControllersSubscriptionsAppStoreVerifyRequest {
    /**
     * 
     * @type {string}
     * @memberof ControllersSubscriptionsAppStoreVerifyRequest
     */
    'app_account_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersSubscriptionsAppStoreVerifyRequest
     */
    'group'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersSubscriptionsAppStoreVerifyRequest
     */
    'group_long_name'?: string;
    /**
     * Optional fields for creating a new group during verification
     * @type {string}
     * @memberof ControllersSubscriptionsAppStoreVerifyRequest
     */
    'group_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersSubscriptionsAppStoreVerifyRequest
     */
    'signature'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllersSubscriptionsAppStoreVerifyRequest
     */
    'signed_transaction_info'?: string;
}
/**
 * 
 * @export
 * @interface ControllersSubscriptionsAppStoreVerifyResponse
 */
export interface ControllersSubscriptionsAppStoreVerifyResponse {
    /**
     * 
     * @type {DunaAuthCommonGroup}
     * @memberof ControllersSubscriptionsAppStoreVerifyResponse
     */
    'group'?: DunaAuthCommonGroup;
    /**
     * 
     * @type {DunaAuthCommonGroupSubscriptionsDto}
     * @memberof ControllersSubscriptionsAppStoreVerifyResponse
     */
    'subscription'?: DunaAuthCommonGroupSubscriptionsDto;
}
/**
 * 
 * @export
 * @interface ControllersUsersBanUserRequest
 */
export interface ControllersUsersBanUserRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ControllersUsersBanUserRequest
     */
    'revokeSessions'?: boolean;
}
/**
 * 
 * @export
 * @interface ControllersUsersRoleAssignmentPayload
 */
export interface ControllersUsersRoleAssignmentPayload {
    /**
     * 
     * @type {string}
     * @memberof ControllersUsersRoleAssignmentPayload
     */
    'identity'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ControllersUsersRoleAssignmentPayload
     */
    'roles'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonCreateCheckoutSessionRequest
 */
export interface DunaAuthCommonCreateCheckoutSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonCreateCheckoutSessionRequest
     */
    'lookupKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonCreateCheckoutSessionRequest
     */
    'organizationLongName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonCreateCheckoutSessionRequest
     */
    'organizationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonCreateCheckoutSessionRequest
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonCreateCheckoutSessionResponse
 */
export interface DunaAuthCommonCreateCheckoutSessionResponse {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonCreateCheckoutSessionResponse
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonCreateCustomerPortalSessionRequest
 */
export interface DunaAuthCommonCreateCustomerPortalSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonCreateCustomerPortalSessionRequest
     */
    'customerId'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonCreateCustomerPortalSessionResponse
 */
export interface DunaAuthCommonCreateCustomerPortalSessionResponse {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonCreateCustomerPortalSessionResponse
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonDeviceKeyUpdate
 */
export interface DunaAuthCommonDeviceKeyUpdate {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonDeviceKeyUpdate
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonDeviceKeyUpdate
     */
    'encryptedGroupKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonDeviceKeyUpdate
     */
    'senderPublicKey'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonDeviceLimitReachedResponse
 */
export interface DunaAuthCommonDeviceLimitReachedResponse {
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonDeviceLimitReachedResponse
     */
    'current'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DunaAuthCommonDeviceLimitReachedResponse
     */
    'limitReached'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonDeviceLimitReachedResponse
     */
    'max'?: number;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGetProductDetailsRequest
 */
export interface DunaAuthCommonGetProductDetailsRequest {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGetProductDetailsRequest
     */
    'lookup_key'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGetProductDetailsResponse
 */
export interface DunaAuthCommonGetProductDetailsResponse {
    /**
     * 
     * @type {CommonStripeProductDetails}
     * @memberof DunaAuthCommonGetProductDetailsResponse
     */
    'product'?: CommonStripeProductDetails;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGetSubscriptionSessionRequest
 */
export interface DunaAuthCommonGetSubscriptionSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGetSubscriptionSessionRequest
     */
    'sessionId'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGetSubscriptionSessionResponse
 */
export interface DunaAuthCommonGetSubscriptionSessionResponse {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGetSubscriptionSessionResponse
     */
    'subscriptionId'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGroup
 */
export interface DunaAuthCommonGroup {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroup
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroup
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonGroup
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroup
     */
    'longName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroup
     */
    'name'?: string;
    /**
     * SubscriptionUUID is the App Store account token for the group.
     * @type {string}
     * @memberof DunaAuthCommonGroup
     */
    'subscriptionUuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroup
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGroupAvailabilityResponse
 */
export interface DunaAuthCommonGroupAvailabilityResponse {
    /**
     * 
     * @type {boolean}
     * @memberof DunaAuthCommonGroupAvailabilityResponse
     */
    'available'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroupAvailabilityResponse
     */
    'signature'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGroupDevicePresenceResponse
 */
export interface DunaAuthCommonGroupDevicePresenceResponse {
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonGroupDevicePresenceResponse
     */
    'count'?: number;
    /**
     * 
     * @type {Array<CommonDevicePresence>}
     * @memberof DunaAuthCommonGroupDevicePresenceResponse
     */
    'devices'?: Array<CommonDevicePresence>;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonGroupDevicePresenceResponse
     */
    'groupId'?: number;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonGroupDevicePresenceResponse
     */
    'max'?: number;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonGroupDevicePresenceResponse
     */
    'offlineCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonGroupDevicePresenceResponse
     */
    'onlineCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonGroupDevicePresenceResponse
     */
    'reachableCount'?: number;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGroupMemberRolesResponse
 */
export interface DunaAuthCommonGroupMemberRolesResponse {
    /**
     * 
     * @type {Array<CommonGroupMemberRole>}
     * @memberof DunaAuthCommonGroupMemberRolesResponse
     */
    'groupRoles'?: Array<CommonGroupMemberRole>;
    /**
     * 
     * @type {CommonUser}
     * @memberof DunaAuthCommonGroupMemberRolesResponse
     */
    'user'?: CommonUser;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGroupMembershipRolesListResponse
 */
export interface DunaAuthCommonGroupMembershipRolesListResponse {
    /**
     * 
     * @type {Array<CommonGroupMemberRole>}
     * @memberof DunaAuthCommonGroupMembershipRolesListResponse
     */
    'groupRoles'?: Array<CommonGroupMemberRole>;
    /**
     * 
     * @type {Array<CommonUser>}
     * @memberof DunaAuthCommonGroupMembershipRolesListResponse
     */
    'users'?: Array<CommonUser>;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGroupSubscriptionsDto
 */
export interface DunaAuthCommonGroupSubscriptionsDto {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'billingCustomerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'billingProvider'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'billingSubscriptionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'endDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'groupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'status'?: string;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'subscriptionId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonGroupSubscriptionsDto
     */
    'tierName'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonGroupsPageResponse
 */
export interface DunaAuthCommonGroupsPageResponse {
    /**
     * 
     * @type {Array<CommonGroup>}
     * @memberof DunaAuthCommonGroupsPageResponse
     */
    'groups'?: Array<CommonGroup>;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonGroupsPageResponse
     */
    'pages'?: number;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonIdentityStateResponse
 */
export interface DunaAuthCommonIdentityStateResponse {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonIdentityStateResponse
     */
    'identity'?: string;
    /**
     * 
     * @type {CommonIdentityState}
     * @memberof DunaAuthCommonIdentityStateResponse
     */
    'state'?: CommonIdentityState;
}


/**
 * 
 * @export
 * @interface DunaAuthCommonKeyRotationResponse
 */
export interface DunaAuthCommonKeyRotationResponse {
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonKeyRotationResponse
     */
    'devicesPendingKeyRequest'?: number;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonKeyRotationResponse
     */
    'devicesUpdated'?: number;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonKeyRotationResponse
     */
    'keyVersion'?: number;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonKeyVersionResponse
 */
export interface DunaAuthCommonKeyVersionResponse {
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonKeyVersionResponse
     */
    'deviceKeyVersion'?: number;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonKeyVersionResponse
     */
    'keyVersion'?: number;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonKeyVersionResponse
     */
    'lastRotatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DunaAuthCommonKeyVersionResponse
     */
    'needsUpdate'?: boolean;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonPaymentTierDto
 */
export interface DunaAuthCommonPaymentTierDto {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonPaymentTierDto
     */
    'billingCycle'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonPaymentTierDto
     */
    'ios_product_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonPaymentTierDto
     */
    'lookupKey'?: string;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonPaymentTierDto
     */
    'maxMembers'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DunaAuthCommonPaymentTierDto
     */
    'platforms'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonPaymentTierDto
     */
    'price'?: number;
    /**
     * 
     * @type {Array<CommonPricingTierDto>}
     * @memberof DunaAuthCommonPaymentTierDto
     */
    'pricingTiers'?: Array<CommonPricingTierDto>;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonPaymentTierDto
     */
    'tierDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonPaymentTierDto
     */
    'tierName'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonRoleResponse
 */
export interface DunaAuthCommonRoleResponse {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonRoleResponse
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonRolesPageResponse
 */
export interface DunaAuthCommonRolesPageResponse {
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonRolesPageResponse
     */
    'pages'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DunaAuthCommonRolesPageResponse
     */
    'roles'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DunaAuthCommonUser
 */
export interface DunaAuthCommonUser {
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonUser
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonUser
     */
    'birthDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonUser
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonUser
     */
    'gender'?: string;
    /**
     * 
     * @type {Array<CommonUserGroupRole>}
     * @memberof DunaAuthCommonUser
     */
    'groupRoles'?: Array<CommonUserGroupRole>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DunaAuthCommonUser
     */
    'groups'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonUser
     */
    'identity'?: string;
    /**
     * 
     * @type {string}
     * @memberof DunaAuthCommonUser
     */
    'lastName'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DunaAuthCommonUser
     */
    'roles'?: Array<string>;
    /**
     * 
     * @type {CommonIdentityState}
     * @memberof DunaAuthCommonUser
     */
    'state'?: CommonIdentityState;
    /**
     * 
     * @type {boolean}
     * @memberof DunaAuthCommonUser
     */
    'verified'?: boolean;
}


/**
 * 
 * @export
 * @interface DunaAuthCommonUsersPageResponse
 */
export interface DunaAuthCommonUsersPageResponse {
    /**
     * 
     * @type {number}
     * @memberof DunaAuthCommonUsersPageResponse
     */
    'pages'?: number;
    /**
     * 
     * @type {Array<CommonUser>}
     * @memberof DunaAuthCommonUsersPageResponse
     */
    'users'?: Array<CommonUser>;
}
/**
 * 
 * @export
 * @interface LicenseStatus
 */
export interface LicenseStatus {
    /**
     * 
     * @type {number}
     * @memberof LicenseStatus
     */
    'daysRemaining'?: number;
    /**
     * 
     * @type {string}
     * @memberof LicenseStatus
     */
    'domain'?: string;
    /**
     * 
     * @type {string}
     * @memberof LicenseStatus
     */
    'exp'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LicenseStatus
     */
    'grace'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LicenseStatus
     */
    'licenseId'?: string;
    /**
     * 
     * @type {string}
     * @memberof LicenseStatus
     */
    'plan'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LicenseStatus
     */
    'valid'?: boolean;
}

/**
 * AdminGroupsApi - axios parameter creator
 * @export
 */
export const AdminGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows admins to check if a group slug is free before provisioning the group.
         * @summary Check if a group name is available (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupAvailableGet: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupAvailableGet', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/admin/group/{group}/available`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns group metadata along with administrative attributes.
         * @summary Get group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupGet: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupGet', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/admin/group/{group}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the specified user from the target group and updates their membership cache.
         * @summary Remove user from group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupMembersDelete: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupMembersDelete', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/admin/group/{group}/members`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the users inside the given group, including admin-only metadata.
         * @summary List group members (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupMembersGet: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupMembersGet', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/admin/group/{group}/members`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds (or invites) a user to the target group, creating the account when needed.
         * @summary Add user to group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupMembersPost: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupMembersPost', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/admin/group/{group}/members`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates any group metadata, including avatar uploads, as an administrator.
         * @summary Update group (admin)
         * @param {string} group Group name
         * @param {DunaAuthCommonGroup} payload Group data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupPost: async (group: string, payload: DunaAuthCommonGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupPost', 'group', group)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupPost', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/admin/group/{group}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the set of roles granted to a group member. Requires admin privileges.
         * @summary Assign roles to group member (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupRolePost: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupRolePost', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/admin/group/{group}/role`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the roles granted to the specified user inside the given group. Requires admin privileges.
         * @summary Get a member\'s roles in a group (admin)
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupRoleUserGet: async (group: string, user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupRoleUserGet', 'group', group)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupGroupRoleUserGet', 'user', user)
            const localVarPath = `/authlance/identity/api/v1/admin/group/{group}/role/{user}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns group metadata by numeric group ID.
         * @summary Get group by ID (admin)
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupIdGroupIdGet: async (groupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupIdGroupIdGet', 'groupId', groupId)
            const localVarPath = `/authlance/identity/api/v1/admin/group/id/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all groups for the specified identity. Useful for administrative audits.
         * @summary List groups for identity
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupMemberIdentityGet: async (identity: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupMemberIdentityGet', 'identity', identity)
            const localVarPath = `/authlance/identity/api/v1/admin/group/member/{identity}`
                .replace(`{${"identity"}}`, encodeURIComponent(String(identity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new group using the provided display name. The logical slug is normalized automatically.
         * @summary Create group
         * @param {DunaAuthCommonGroup} payload Group to create (id &#x3D; -1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupPut: async (payload: DunaAuthCommonGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupPut', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/admin/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists each member within the group alongside their assigned roles.
         * @summary List roles assigned within a group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupRolesGroupGet: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupRolesGroupGet', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/admin/group/roles/{group}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Paginates through groups with optional filters by name.
         * @summary List groups
         * @param {number} page Page number
         * @param {number} [perPage] Per-page size
         * @param {string} [filter] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupsPageGet: async (page: number, perPage?: number, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminGroupsPageGet', 'page', page)
            const localVarPath = `/authlance/identity/api/v1/admin/groups/{page}`
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminGroupsApi - functional programming interface
 * @export
 */
export const AdminGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows admins to check if a group slug is free before provisioning the group.
         * @summary Check if a group name is available (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupGroupAvailableGet(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupAvailabilityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupGroupAvailableGet(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupGroupAvailableGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns group metadata along with administrative attributes.
         * @summary Get group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupGroupGet(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupGroupGet(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupGroupGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the specified user from the target group and updates their membership cache.
         * @summary Remove user from group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupGroupMembersDelete(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupGroupMembersDelete(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupGroupMembersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists the users inside the given group, including admin-only metadata.
         * @summary List group members (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupGroupMembersGet(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DunaAuthCommonUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupGroupMembersGet(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupGroupMembersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds (or invites) a user to the target group, creating the account when needed.
         * @summary Add user to group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupGroupMembersPost(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupGroupMembersPost(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupGroupMembersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates any group metadata, including avatar uploads, as an administrator.
         * @summary Update group (admin)
         * @param {string} group Group name
         * @param {DunaAuthCommonGroup} payload Group data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupGroupPost(group: string, payload: DunaAuthCommonGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupGroupPost(group, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupGroupPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replaces the set of roles granted to a group member. Requires admin privileges.
         * @summary Assign roles to group member (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupGroupRolePost(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupGroupRolePost(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupGroupRolePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the roles granted to the specified user inside the given group. Requires admin privileges.
         * @summary Get a member\'s roles in a group (admin)
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupMemberRolesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupGroupRoleUserGet(group, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupGroupRoleUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns group metadata by numeric group ID.
         * @summary Get group by ID (admin)
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupIdGroupIdGet(groupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupIdGroupIdGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupIdGroupIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all groups for the specified identity. Useful for administrative audits.
         * @summary List groups for identity
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupMemberIdentityGet(identity: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DunaAuthCommonGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupMemberIdentityGet(identity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupMemberIdentityGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new group using the provided display name. The logical slug is normalized automatically.
         * @summary Create group
         * @param {DunaAuthCommonGroup} payload Group to create (id &#x3D; -1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupPut(payload: DunaAuthCommonGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupPut(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists each member within the group alongside their assigned roles.
         * @summary List roles assigned within a group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupRolesGroupGet(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupMembershipRolesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupRolesGroupGet(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupRolesGroupGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Paginates through groups with optional filters by name.
         * @summary List groups
         * @param {number} page Page number
         * @param {number} [perPage] Per-page size
         * @param {string} [filter] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminGroupsPageGet(page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupsPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminGroupsPageGet(page, perPage, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminGroupsApi.authlanceIdentityApiV1AdminGroupsPageGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminGroupsApi - factory interface
 * @export
 */
export const AdminGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminGroupsApiFp(configuration)
    return {
        /**
         * Allows admins to check if a group slug is free before provisioning the group.
         * @summary Check if a group name is available (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupAvailableGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupAvailabilityResponse> {
            return localVarFp.authlanceIdentityApiV1AdminGroupGroupAvailableGet(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns group metadata along with administrative attributes.
         * @summary Get group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup> {
            return localVarFp.authlanceIdentityApiV1AdminGroupGroupGet(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the specified user from the target group and updates their membership cache.
         * @summary Remove user from group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupMembersDelete(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1AdminGroupGroupMembersDelete(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the users inside the given group, including admin-only metadata.
         * @summary List group members (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupMembersGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonUser>> {
            return localVarFp.authlanceIdentityApiV1AdminGroupGroupMembersGet(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds (or invites) a user to the target group, creating the account when needed.
         * @summary Add user to group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupMembersPost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1AdminGroupGroupMembersPost(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates any group metadata, including avatar uploads, as an administrator.
         * @summary Update group (admin)
         * @param {string} group Group name
         * @param {DunaAuthCommonGroup} payload Group data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupPost(group: string, payload: DunaAuthCommonGroup, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup> {
            return localVarFp.authlanceIdentityApiV1AdminGroupGroupPost(group, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the set of roles granted to a group member. Requires admin privileges.
         * @summary Assign roles to group member (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupRolePost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1AdminGroupGroupRolePost(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the roles granted to the specified user inside the given group. Requires admin privileges.
         * @summary Get a member\'s roles in a group (admin)
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMemberRolesResponse> {
            return localVarFp.authlanceIdentityApiV1AdminGroupGroupRoleUserGet(group, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns group metadata by numeric group ID.
         * @summary Get group by ID (admin)
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupIdGroupIdGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup> {
            return localVarFp.authlanceIdentityApiV1AdminGroupIdGroupIdGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all groups for the specified identity. Useful for administrative audits.
         * @summary List groups for identity
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupMemberIdentityGet(identity: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonGroup>> {
            return localVarFp.authlanceIdentityApiV1AdminGroupMemberIdentityGet(identity, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new group using the provided display name. The logical slug is normalized automatically.
         * @summary Create group
         * @param {DunaAuthCommonGroup} payload Group to create (id &#x3D; -1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupPut(payload: DunaAuthCommonGroup, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup> {
            return localVarFp.authlanceIdentityApiV1AdminGroupPut(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists each member within the group alongside their assigned roles.
         * @summary List roles assigned within a group (admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupRolesGroupGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMembershipRolesListResponse> {
            return localVarFp.authlanceIdentityApiV1AdminGroupRolesGroupGet(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Paginates through groups with optional filters by name.
         * @summary List groups
         * @param {number} page Page number
         * @param {number} [perPage] Per-page size
         * @param {string} [filter] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminGroupsPageGet(page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupsPageResponse> {
            return localVarFp.authlanceIdentityApiV1AdminGroupsPageGet(page, perPage, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminGroupsApi - interface
 * @export
 * @interface AdminGroupsApi
 */
export interface AdminGroupsApiInterface {
    /**
     * Allows admins to check if a group slug is free before provisioning the group.
     * @summary Check if a group name is available (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupGroupAvailableGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupAvailabilityResponse>;

    /**
     * Returns group metadata along with administrative attributes.
     * @summary Get group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupGroupGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup>;

    /**
     * Removes the specified user from the target group and updates their membership cache.
     * @summary Remove user from group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupGroupMembersDelete(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Lists the users inside the given group, including admin-only metadata.
     * @summary List group members (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupGroupMembersGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonUser>>;

    /**
     * Adds (or invites) a user to the target group, creating the account when needed.
     * @summary Add user to group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupGroupMembersPost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Updates any group metadata, including avatar uploads, as an administrator.
     * @summary Update group (admin)
     * @param {string} group Group name
     * @param {DunaAuthCommonGroup} payload Group data to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupGroupPost(group: string, payload: DunaAuthCommonGroup, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup>;

    /**
     * Replaces the set of roles granted to a group member. Requires admin privileges.
     * @summary Assign roles to group member (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupGroupRolePost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Returns the roles granted to the specified user inside the given group. Requires admin privileges.
     * @summary Get a member\'s roles in a group (admin)
     * @param {string} group Group name
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMemberRolesResponse>;

    /**
     * Returns group metadata by numeric group ID.
     * @summary Get group by ID (admin)
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupIdGroupIdGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup>;

    /**
     * Lists all groups for the specified identity. Useful for administrative audits.
     * @summary List groups for identity
     * @param {string} identity Identity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupMemberIdentityGet(identity: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonGroup>>;

    /**
     * Creates a new group using the provided display name. The logical slug is normalized automatically.
     * @summary Create group
     * @param {DunaAuthCommonGroup} payload Group to create (id &#x3D; -1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupPut(payload: DunaAuthCommonGroup, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup>;

    /**
     * Lists each member within the group alongside their assigned roles.
     * @summary List roles assigned within a group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupRolesGroupGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMembershipRolesListResponse>;

    /**
     * Paginates through groups with optional filters by name.
     * @summary List groups
     * @param {number} page Page number
     * @param {number} [perPage] Per-page size
     * @param {string} [filter] Filter by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApiInterface
     */
    authlanceIdentityApiV1AdminGroupsPageGet(page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupsPageResponse>;

}

/**
 * AdminGroupsApi - object-oriented interface
 * @export
 * @class AdminGroupsApi
 * @extends {BaseAPI}
 */
export class AdminGroupsApi extends BaseAPI implements AdminGroupsApiInterface {
    /**
     * Allows admins to check if a group slug is free before provisioning the group.
     * @summary Check if a group name is available (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupGroupAvailableGet(group: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupGroupAvailableGet(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns group metadata along with administrative attributes.
     * @summary Get group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupGroupGet(group: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupGroupGet(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the specified user from the target group and updates their membership cache.
     * @summary Remove user from group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupGroupMembersDelete(group: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupGroupMembersDelete(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the users inside the given group, including admin-only metadata.
     * @summary List group members (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupGroupMembersGet(group: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupGroupMembersGet(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds (or invites) a user to the target group, creating the account when needed.
     * @summary Add user to group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupGroupMembersPost(group: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupGroupMembersPost(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates any group metadata, including avatar uploads, as an administrator.
     * @summary Update group (admin)
     * @param {string} group Group name
     * @param {DunaAuthCommonGroup} payload Group data to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupGroupPost(group: string, payload: DunaAuthCommonGroup, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupGroupPost(group, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the set of roles granted to a group member. Requires admin privileges.
     * @summary Assign roles to group member (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupGroupRolePost(group: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupGroupRolePost(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the roles granted to the specified user inside the given group. Requires admin privileges.
     * @summary Get a member\'s roles in a group (admin)
     * @param {string} group Group name
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupGroupRoleUserGet(group, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns group metadata by numeric group ID.
     * @summary Get group by ID (admin)
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupIdGroupIdGet(groupId: number, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupIdGroupIdGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all groups for the specified identity. Useful for administrative audits.
     * @summary List groups for identity
     * @param {string} identity Identity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupMemberIdentityGet(identity: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupMemberIdentityGet(identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new group using the provided display name. The logical slug is normalized automatically.
     * @summary Create group
     * @param {DunaAuthCommonGroup} payload Group to create (id &#x3D; -1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupPut(payload: DunaAuthCommonGroup, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupPut(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists each member within the group alongside their assigned roles.
     * @summary List roles assigned within a group (admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupRolesGroupGet(group: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupRolesGroupGet(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Paginates through groups with optional filters by name.
     * @summary List groups
     * @param {number} page Page number
     * @param {number} [perPage] Per-page size
     * @param {string} [filter] Filter by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminGroupsApi
     */
    public authlanceIdentityApiV1AdminGroupsPageGet(page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig) {
        return AdminGroupsApiFp(this.configuration).authlanceIdentityApiV1AdminGroupsPageGet(page, perPage, filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminRolesApi - axios parameter creator
 * @export
 */
export const AdminRolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Registers a new platform role that can later be assigned to identities.
         * @summary Create role
         * @param {DunaAuthCommonRoleResponse} payload { name: roleName }
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminRolePut: async (payload: DunaAuthCommonRoleResponse, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminRolePut', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/admin/role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists platform roles available for assignment, including pagination and filters.
         * @summary List system roles (admin)
         * @param {number} page Page number
         * @param {number} [perPage] Page size
         * @param {string} [filter] Text filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminRolesPageGet: async (page: number, perPage?: number, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminRolesPageGet', 'page', page)
            const localVarPath = `/authlance/identity/api/v1/admin/roles/{page}`
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the set of global roles attached to the specified identity.
         * @summary Assign roles to user
         * @param {ControllersUsersRoleAssignmentPayload} payload Identity and roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserRolePut: async (payload: ControllersUsersRoleAssignmentPayload, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminUserRolePut', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/admin/user/role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminRolesApi - functional programming interface
 * @export
 */
export const AdminRolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminRolesApiAxiosParamCreator(configuration)
    return {
        /**
         * Registers a new platform role that can later be assigned to identities.
         * @summary Create role
         * @param {DunaAuthCommonRoleResponse} payload { name: roleName }
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminRolePut(payload: DunaAuthCommonRoleResponse, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminRolePut(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminRolesApi.authlanceIdentityApiV1AdminRolePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists platform roles available for assignment, including pagination and filters.
         * @summary List system roles (admin)
         * @param {number} page Page number
         * @param {number} [perPage] Page size
         * @param {string} [filter] Text filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminRolesPageGet(page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonRolesPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminRolesPageGet(page, perPage, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminRolesApi.authlanceIdentityApiV1AdminRolesPageGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replaces the set of global roles attached to the specified identity.
         * @summary Assign roles to user
         * @param {ControllersUsersRoleAssignmentPayload} payload Identity and roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminUserRolePut(payload: ControllersUsersRoleAssignmentPayload, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminUserRolePut(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminRolesApi.authlanceIdentityApiV1AdminUserRolePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminRolesApi - factory interface
 * @export
 */
export const AdminRolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminRolesApiFp(configuration)
    return {
        /**
         * Registers a new platform role that can later be assigned to identities.
         * @summary Create role
         * @param {DunaAuthCommonRoleResponse} payload { name: roleName }
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminRolePut(payload: DunaAuthCommonRoleResponse, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonRoleResponse> {
            return localVarFp.authlanceIdentityApiV1AdminRolePut(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists platform roles available for assignment, including pagination and filters.
         * @summary List system roles (admin)
         * @param {number} page Page number
         * @param {number} [perPage] Page size
         * @param {string} [filter] Text filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminRolesPageGet(page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonRolesPageResponse> {
            return localVarFp.authlanceIdentityApiV1AdminRolesPageGet(page, perPage, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the set of global roles attached to the specified identity.
         * @summary Assign roles to user
         * @param {ControllersUsersRoleAssignmentPayload} payload Identity and roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserRolePut(payload: ControllersUsersRoleAssignmentPayload, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1AdminUserRolePut(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminRolesApi - interface
 * @export
 * @interface AdminRolesApi
 */
export interface AdminRolesApiInterface {
    /**
     * Registers a new platform role that can later be assigned to identities.
     * @summary Create role
     * @param {DunaAuthCommonRoleResponse} payload { name: roleName }
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRolesApiInterface
     */
    authlanceIdentityApiV1AdminRolePut(payload: DunaAuthCommonRoleResponse, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonRoleResponse>;

    /**
     * Lists platform roles available for assignment, including pagination and filters.
     * @summary List system roles (admin)
     * @param {number} page Page number
     * @param {number} [perPage] Page size
     * @param {string} [filter] Text filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRolesApiInterface
     */
    authlanceIdentityApiV1AdminRolesPageGet(page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonRolesPageResponse>;

    /**
     * Replaces the set of global roles attached to the specified identity.
     * @summary Assign roles to user
     * @param {ControllersUsersRoleAssignmentPayload} payload Identity and roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRolesApiInterface
     */
    authlanceIdentityApiV1AdminUserRolePut(payload: ControllersUsersRoleAssignmentPayload, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

}

/**
 * AdminRolesApi - object-oriented interface
 * @export
 * @class AdminRolesApi
 * @extends {BaseAPI}
 */
export class AdminRolesApi extends BaseAPI implements AdminRolesApiInterface {
    /**
     * Registers a new platform role that can later be assigned to identities.
     * @summary Create role
     * @param {DunaAuthCommonRoleResponse} payload { name: roleName }
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRolesApi
     */
    public authlanceIdentityApiV1AdminRolePut(payload: DunaAuthCommonRoleResponse, options?: RawAxiosRequestConfig) {
        return AdminRolesApiFp(this.configuration).authlanceIdentityApiV1AdminRolePut(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists platform roles available for assignment, including pagination and filters.
     * @summary List system roles (admin)
     * @param {number} page Page number
     * @param {number} [perPage] Page size
     * @param {string} [filter] Text filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRolesApi
     */
    public authlanceIdentityApiV1AdminRolesPageGet(page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig) {
        return AdminRolesApiFp(this.configuration).authlanceIdentityApiV1AdminRolesPageGet(page, perPage, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the set of global roles attached to the specified identity.
     * @summary Assign roles to user
     * @param {ControllersUsersRoleAssignmentPayload} payload Identity and roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminRolesApi
     */
    public authlanceIdentityApiV1AdminUserRolePut(payload: ControllersUsersRoleAssignmentPayload, options?: RawAxiosRequestConfig) {
        return AdminRolesApiFp(this.configuration).authlanceIdentityApiV1AdminUserRolePut(payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminSubscriptionsApi - axios parameter creator
 * @export
 */
export const AdminSubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all subscriptions for the specified group by group ID.
         * @summary List subscriptions for a group (admin)
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminSubscriptionsGroupGroupIdGet: async (groupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminSubscriptionsGroupGroupIdGet', 'groupId', groupId)
            const localVarPath = `/authlance/identity/api/v1/admin/subscriptions/group/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminSubscriptionsApi - functional programming interface
 * @export
 */
export const AdminSubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminSubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all subscriptions for the specified group by group ID.
         * @summary List subscriptions for a group (admin)
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminSubscriptionsGroupGroupIdGet(groupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DunaAuthCommonGroupSubscriptionsDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminSubscriptionsGroupGroupIdGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminSubscriptionsApi.authlanceIdentityApiV1AdminSubscriptionsGroupGroupIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminSubscriptionsApi - factory interface
 * @export
 */
export const AdminSubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminSubscriptionsApiFp(configuration)
    return {
        /**
         * Returns all subscriptions for the specified group by group ID.
         * @summary List subscriptions for a group (admin)
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminSubscriptionsGroupGroupIdGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonGroupSubscriptionsDto>> {
            return localVarFp.authlanceIdentityApiV1AdminSubscriptionsGroupGroupIdGet(groupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminSubscriptionsApi - interface
 * @export
 * @interface AdminSubscriptionsApi
 */
export interface AdminSubscriptionsApiInterface {
    /**
     * Returns all subscriptions for the specified group by group ID.
     * @summary List subscriptions for a group (admin)
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminSubscriptionsApiInterface
     */
    authlanceIdentityApiV1AdminSubscriptionsGroupGroupIdGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonGroupSubscriptionsDto>>;

}

/**
 * AdminSubscriptionsApi - object-oriented interface
 * @export
 * @class AdminSubscriptionsApi
 * @extends {BaseAPI}
 */
export class AdminSubscriptionsApi extends BaseAPI implements AdminSubscriptionsApiInterface {
    /**
     * Returns all subscriptions for the specified group by group ID.
     * @summary List subscriptions for a group (admin)
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminSubscriptionsApi
     */
    public authlanceIdentityApiV1AdminSubscriptionsGroupGroupIdGet(groupId: number, options?: RawAxiosRequestConfig) {
        return AdminSubscriptionsApiFp(this.configuration).authlanceIdentityApiV1AdminSubscriptionsGroupGroupIdGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminUsersApi - axios parameter creator
 * @export
 */
export const AdminUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deactivates a user\'s identity and optionally revokes active sessions.
         * @summary Ban user
         * @param {string} identity Identity ID
         * @param {ControllersUsersBanUserRequest} [payload] Ban options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserIdentityBanPost: async (identity: string, payload?: ControllersUsersBanUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminUserIdentityBanPost', 'identity', identity)
            const localVarPath = `/authlance/identity/api/v1/admin/user/{identity}/ban`
                .replace(`{${"identity"}}`, encodeURIComponent(String(identity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a user profile by identity identifier.
         * @summary Find user by identity
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserIdentityGet: async (identity: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminUserIdentityGet', 'identity', identity)
            const localVarPath = `/authlance/identity/api/v1/admin/user/{identity}`
                .replace(`{${"identity"}}`, encodeURIComponent(String(identity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reactivates a previously banned user\'s identity.
         * @summary Unban user
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserIdentityUnbanPost: async (identity: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identity' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminUserIdentityUnbanPost', 'identity', identity)
            const localVarPath = `/authlance/identity/api/v1/admin/user/{identity}/unban`
                .replace(`{${"identity"}}`, encodeURIComponent(String(identity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin endpoint to update any user profile. JSON payloads update basic attributes and multipart bodies may include an avatar upload.
         * @summary Update user (admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/identity/api/v1/admin/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user identity and seeds it with the provided global roles.
         * @summary Create user
         * @param {DunaAuthCommonUser} payload User to create (set identityId to -1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserPut: async (payload: DunaAuthCommonUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminUserPut', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/admin/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Paginates over users with optional filter by name or email.
         * @summary List users
         * @param {number} page Page number
         * @param {string} [filter] Filter by name or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUsersPageGet: async (page: number, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminUsersPageGet', 'page', page)
            const localVarPath = `/authlance/identity/api/v1/admin/users/{page}`
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminUsersApi - functional programming interface
 * @export
 */
export const AdminUsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminUsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Deactivates a user\'s identity and optionally revokes active sessions.
         * @summary Ban user
         * @param {string} identity Identity ID
         * @param {ControllersUsersBanUserRequest} [payload] Ban options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminUserIdentityBanPost(identity: string, payload?: ControllersUsersBanUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonIdentityStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminUserIdentityBanPost(identity, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.authlanceIdentityApiV1AdminUserIdentityBanPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a user profile by identity identifier.
         * @summary Find user by identity
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminUserIdentityGet(identity: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminUserIdentityGet(identity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.authlanceIdentityApiV1AdminUserIdentityGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reactivates a previously banned user\'s identity.
         * @summary Unban user
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminUserIdentityUnbanPost(identity: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonIdentityStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminUserIdentityUnbanPost(identity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.authlanceIdentityApiV1AdminUserIdentityUnbanPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admin endpoint to update any user profile. JSON payloads update basic attributes and multipart bodies may include an avatar upload.
         * @summary Update user (admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminUserPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminUserPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.authlanceIdentityApiV1AdminUserPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user identity and seeds it with the provided global roles.
         * @summary Create user
         * @param {DunaAuthCommonUser} payload User to create (set identityId to -1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminUserPut(payload: DunaAuthCommonUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminUserPut(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.authlanceIdentityApiV1AdminUserPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Paginates over users with optional filter by name or email.
         * @summary List users
         * @param {number} page Page number
         * @param {string} [filter] Filter by name or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminUsersPageGet(page: number, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUsersPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminUsersPageGet(page, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.authlanceIdentityApiV1AdminUsersPageGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminUsersApi - factory interface
 * @export
 */
export const AdminUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminUsersApiFp(configuration)
    return {
        /**
         * Deactivates a user\'s identity and optionally revokes active sessions.
         * @summary Ban user
         * @param {string} identity Identity ID
         * @param {ControllersUsersBanUserRequest} [payload] Ban options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserIdentityBanPost(identity: string, payload?: ControllersUsersBanUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonIdentityStateResponse> {
            return localVarFp.authlanceIdentityApiV1AdminUserIdentityBanPost(identity, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a user profile by identity identifier.
         * @summary Find user by identity
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserIdentityGet(identity: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1AdminUserIdentityGet(identity, options).then((request) => request(axios, basePath));
        },
        /**
         * Reactivates a previously banned user\'s identity.
         * @summary Unban user
         * @param {string} identity Identity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserIdentityUnbanPost(identity: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonIdentityStateResponse> {
            return localVarFp.authlanceIdentityApiV1AdminUserIdentityUnbanPost(identity, options).then((request) => request(axios, basePath));
        },
        /**
         * Admin endpoint to update any user profile. JSON payloads update basic attributes and multipart bodies may include an avatar upload.
         * @summary Update user (admin)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserPost(options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1AdminUserPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user identity and seeds it with the provided global roles.
         * @summary Create user
         * @param {DunaAuthCommonUser} payload User to create (set identityId to -1)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUserPut(payload: DunaAuthCommonUser, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1AdminUserPut(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Paginates over users with optional filter by name or email.
         * @summary List users
         * @param {number} page Page number
         * @param {string} [filter] Filter by name or email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminUsersPageGet(page: number, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUsersPageResponse> {
            return localVarFp.authlanceIdentityApiV1AdminUsersPageGet(page, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminUsersApi - interface
 * @export
 * @interface AdminUsersApi
 */
export interface AdminUsersApiInterface {
    /**
     * Deactivates a user\'s identity and optionally revokes active sessions.
     * @summary Ban user
     * @param {string} identity Identity ID
     * @param {ControllersUsersBanUserRequest} [payload] Ban options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApiInterface
     */
    authlanceIdentityApiV1AdminUserIdentityBanPost(identity: string, payload?: ControllersUsersBanUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonIdentityStateResponse>;

    /**
     * Retrieves a user profile by identity identifier.
     * @summary Find user by identity
     * @param {string} identity Identity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApiInterface
     */
    authlanceIdentityApiV1AdminUserIdentityGet(identity: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Reactivates a previously banned user\'s identity.
     * @summary Unban user
     * @param {string} identity Identity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApiInterface
     */
    authlanceIdentityApiV1AdminUserIdentityUnbanPost(identity: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonIdentityStateResponse>;

    /**
     * Admin endpoint to update any user profile. JSON payloads update basic attributes and multipart bodies may include an avatar upload.
     * @summary Update user (admin)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApiInterface
     */
    authlanceIdentityApiV1AdminUserPost(options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Creates a new user identity and seeds it with the provided global roles.
     * @summary Create user
     * @param {DunaAuthCommonUser} payload User to create (set identityId to -1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApiInterface
     */
    authlanceIdentityApiV1AdminUserPut(payload: DunaAuthCommonUser, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Paginates over users with optional filter by name or email.
     * @summary List users
     * @param {number} page Page number
     * @param {string} [filter] Filter by name or email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApiInterface
     */
    authlanceIdentityApiV1AdminUsersPageGet(page: number, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUsersPageResponse>;

}

/**
 * AdminUsersApi - object-oriented interface
 * @export
 * @class AdminUsersApi
 * @extends {BaseAPI}
 */
export class AdminUsersApi extends BaseAPI implements AdminUsersApiInterface {
    /**
     * Deactivates a user\'s identity and optionally revokes active sessions.
     * @summary Ban user
     * @param {string} identity Identity ID
     * @param {ControllersUsersBanUserRequest} [payload] Ban options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public authlanceIdentityApiV1AdminUserIdentityBanPost(identity: string, payload?: ControllersUsersBanUserRequest, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).authlanceIdentityApiV1AdminUserIdentityBanPost(identity, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a user profile by identity identifier.
     * @summary Find user by identity
     * @param {string} identity Identity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public authlanceIdentityApiV1AdminUserIdentityGet(identity: string, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).authlanceIdentityApiV1AdminUserIdentityGet(identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reactivates a previously banned user\'s identity.
     * @summary Unban user
     * @param {string} identity Identity ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public authlanceIdentityApiV1AdminUserIdentityUnbanPost(identity: string, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).authlanceIdentityApiV1AdminUserIdentityUnbanPost(identity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admin endpoint to update any user profile. JSON payloads update basic attributes and multipart bodies may include an avatar upload.
     * @summary Update user (admin)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public authlanceIdentityApiV1AdminUserPost(options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).authlanceIdentityApiV1AdminUserPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user identity and seeds it with the provided global roles.
     * @summary Create user
     * @param {DunaAuthCommonUser} payload User to create (set identityId to -1)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public authlanceIdentityApiV1AdminUserPut(payload: DunaAuthCommonUser, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).authlanceIdentityApiV1AdminUserPut(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Paginates over users with optional filter by name or email.
     * @summary List users
     * @param {number} page Page number
     * @param {string} [filter] Filter by name or email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public authlanceIdentityApiV1AdminUsersPageGet(page: number, filter?: string, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).authlanceIdentityApiV1AdminUsersPageGet(page, filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Clears the authentication cookie to log out the user.
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityMeLogoutGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/identity/me/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts a `session` ID and returns a signed JWT used for the protected API.
         * @summary Exchange a session for JWT
         * @param {ControllersAuthAuthRequest} payload Authentication payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityMePost: async (payload: ControllersAuthAuthRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityMePost', 'payload', payload)
            const localVarPath = `/authlance/identity/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Clears the authentication cookie to log out the user.
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityMeLogoutGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersAuthLogoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityMeLogoutGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authlanceIdentityMeLogoutGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Accepts a `session` ID and returns a signed JWT used for the protected API.
         * @summary Exchange a session for JWT
         * @param {ControllersAuthAuthRequest} payload Authentication payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityMePost(payload: ControllersAuthAuthRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersAuthAuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityMePost(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authlanceIdentityMePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Clears the authentication cookie to log out the user.
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityMeLogoutGet(options?: RawAxiosRequestConfig): AxiosPromise<ControllersAuthLogoutResponse> {
            return localVarFp.authlanceIdentityMeLogoutGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts a `session` ID and returns a signed JWT used for the protected API.
         * @summary Exchange a session for JWT
         * @param {ControllersAuthAuthRequest} payload Authentication payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityMePost(payload: ControllersAuthAuthRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersAuthAuthResponse> {
            return localVarFp.authlanceIdentityMePost(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * Clears the authentication cookie to log out the user.
     * @summary Logout user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authlanceIdentityMeLogoutGet(options?: RawAxiosRequestConfig): AxiosPromise<ControllersAuthLogoutResponse>;

    /**
     * Accepts a `session` ID and returns a signed JWT used for the protected API.
     * @summary Exchange a session for JWT
     * @param {ControllersAuthAuthRequest} payload Authentication payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authlanceIdentityMePost(payload: ControllersAuthAuthRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersAuthAuthResponse>;

}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * Clears the authentication cookie to log out the user.
     * @summary Logout user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authlanceIdentityMeLogoutGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authlanceIdentityMeLogoutGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts a `session` ID and returns a signed JWT used for the protected API.
     * @summary Exchange a session for JWT
     * @param {ControllersAuthAuthRequest} payload Authentication payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authlanceIdentityMePost(payload: ControllersAuthAuthRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authlanceIdentityMePost(payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes a device from the group (admin only)
         * @summary Remove a device
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdDelete: async (groupId: number, deviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdDelete', 'groupId', groupId)
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdDelete', 'deviceId', deviceId)
            const localVarPath = `/authlance/identity/api/v1/realm/admin/groups/{groupId}/devices/{deviceId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revokes a device (admin only). Optionally includes rotation data to atomically revoke and rotate.
         * @summary Revoke a device
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {ControllersDevicesRevokeWithRotationRequest} [payload] Optional rotation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdRevokePost: async (groupId: number, deviceId: string, payload?: ControllersDevicesRevokeWithRotationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdRevokePost', 'groupId', groupId)
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdRevokePost', 'deviceId', deviceId)
            const localVarPath = `/authlance/identity/api/v1/realm/admin/groups/{groupId}/devices/{deviceId}/revoke`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rotates the group key and re-encrypts secrets (admin only)
         * @summary Rotate group encryption key
         * @param {number} groupId Group ID
         * @param {ControllersDevicesRotateKeyRequest} payload Rotation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupsGroupIdKeysRotatePost: async (groupId: number, payload: ControllersDevicesRotateKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupsGroupIdKeysRotatePost', 'groupId', groupId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupsGroupIdKeysRotatePost', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/realm/admin/groups/{groupId}/keys/rotate`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the count of active devices in a group (for subscription enforcement)
         * @summary Get device count
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesCountGet: async (groupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesCountGet', 'groupId', groupId)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/devices/count`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates a device with its encrypted group key
         * @summary Activate a device
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {ControllersDevicesActivateDeviceRequest} payload Activation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdActivatePost: async (groupId: number, deviceId: string, payload: ControllersDevicesActivateDeviceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdActivatePost', 'groupId', groupId)
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdActivatePost', 'deviceId', deviceId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdActivatePost', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/devices/{deviceId}/activate`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific device by ID
         * @summary Get a device
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdGet: async (groupId: number, deviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdGet', 'groupId', groupId)
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdGet', 'deviceId', deviceId)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/devices/{deviceId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the last seen timestamp for a device
         * @summary Update device heartbeat
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdHeartbeatPost: async (groupId: number, deviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdHeartbeatPost', 'groupId', groupId)
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdHeartbeatPost', 'deviceId', deviceId)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/devices/{deviceId}/heartbeat`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the encrypted group key for a device (if updated during rotation)
         * @summary Get device\'s encrypted group key
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdKeyGet: async (groupId: number, deviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdKeyGet', 'groupId', groupId)
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdKeyGet', 'deviceId', deviceId)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/devices/{deviceId}/key`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the public key for a device. Used for key migration scenarios.
         * @summary Update device public key
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {ControllersDevicesUpdatePublicKeyRequest} payload Public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPublicKeyPut: async (groupId: number, deviceId: string, payload: ControllersDevicesUpdatePublicKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPublicKeyPut', 'groupId', groupId)
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPublicKeyPut', 'deviceId', deviceId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPublicKeyPut', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/devices/{deviceId}/public-key`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clears the push notification token for a device
         * @summary Clear device push token
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenDelete: async (groupId: number, deviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenDelete', 'groupId', groupId)
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenDelete', 'deviceId', deviceId)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/devices/{deviceId}/push-token`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the push notification token for a device
         * @summary Update device push token
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {ControllersDevicesUpdatePushTokenRequest} payload Push token payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenPut: async (groupId: number, deviceId: string, payload: ControllersDevicesUpdatePushTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenPut', 'groupId', groupId)
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenPut', 'deviceId', deviceId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenPut', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/devices/{deviceId}/push-token`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Opens an SSE connection to receive real-time device events for a group
         * @summary Subscribe to group device events
         * @param {number} groupId Group ID
         * @param {string} [deviceId] Device ID (optional, for device-specific events)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesEventsGet: async (groupId: number, deviceId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesEventsGet', 'groupId', groupId)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/devices/events`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all devices registered in a group
         * @summary List devices in a group
         * @param {number} groupId Group ID
         * @param {string} [status] Filter by status (active, pending, revoked)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesGet: async (groupId: number, status?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesGet', 'groupId', groupId)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/devices`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all pending key requests for a group
         * @summary List pending key requests
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsGet: async (groupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsGet', 'groupId', groupId)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/devices/key-requests`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a request to receive the encrypted group key from another device
         * @summary Create a key sharing request
         * @param {number} groupId Group ID
         * @param {ControllersDevicesCreateKeyRequestRequest} payload Key request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsPost: async (groupId: number, payload: ControllersDevicesCreateKeyRequestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsPost', 'groupId', groupId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsPost', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/devices/key-requests`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific key request by ID
         * @summary Get a key request
         * @param {number} groupId Group ID
         * @param {string} requestId Request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGet: async (groupId: number, requestId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGet', 'groupId', groupId)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGet', 'requestId', requestId)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/devices/key-requests/{requestId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Grants a key request by providing the encrypted group key
         * @summary Grant a key request
         * @param {number} groupId Group ID
         * @param {string} requestId Request ID
         * @param {ControllersDevicesGrantKeyRequestRequest} payload Grant payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGrantPost: async (groupId: number, requestId: string, payload: ControllersDevicesGrantKeyRequestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGrantPost', 'groupId', groupId)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGrantPost', 'requestId', requestId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGrantPost', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/devices/key-requests/{requestId}/grant`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rejects a pending key request
         * @summary Reject a key request
         * @param {number} groupId Group ID
         * @param {string} requestId Request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdRejectPost: async (groupId: number, requestId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdRejectPost', 'groupId', groupId)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdRejectPost', 'requestId', requestId)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/devices/key-requests/{requestId}/reject`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"requestId"}}`, encodeURIComponent(String(requestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a new device for the current user in a group
         * @summary Register a new device
         * @param {number} groupId Group ID
         * @param {ControllersDevicesRegisterDeviceRequest} payload Device registration payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesPost: async (groupId: number, payload: ControllersDevicesRegisterDeviceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesPost', 'groupId', groupId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesPost', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/devices`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets real-time presence information for all devices in a group
         * @summary Get device presence
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesPresenceGet: async (groupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdDevicesPresenceGet', 'groupId', groupId)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/devices/presence`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns current key version and whether device needs update
         * @summary Get key version info
         * @param {number} groupId Group ID
         * @param {string} [deviceId] Device ID (optional, uses current user\&#39;s device if not specified)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdKeysVersionGet: async (groupId: number, deviceId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdKeysVersionGet', 'groupId', groupId)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/keys/version`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes a device from the group (admin only)
         * @summary Remove a device
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdDelete(groupId: number, deviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdDelete(groupId, deviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revokes a device (admin only). Optionally includes rotation data to atomically revoke and rotate.
         * @summary Revoke a device
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {ControllersDevicesRevokeWithRotationRequest} [payload] Optional rotation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdRevokePost(groupId: number, deviceId: string, payload?: ControllersDevicesRevokeWithRotationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonKeyRotationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdRevokePost(groupId, deviceId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdRevokePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rotates the group key and re-encrypts secrets (admin only)
         * @summary Rotate group encryption key
         * @param {number} groupId Group ID
         * @param {ControllersDevicesRotateKeyRequest} payload Rotation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmAdminGroupsGroupIdKeysRotatePost(groupId: number, payload: ControllersDevicesRotateKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonKeyRotationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmAdminGroupsGroupIdKeysRotatePost(groupId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmAdminGroupsGroupIdKeysRotatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the count of active devices in a group (for subscription enforcement)
         * @summary Get device count
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdDevicesCountGet(groupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonDeviceLimitReachedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdDevicesCountGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdDevicesCountGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Activates a device with its encrypted group key
         * @summary Activate a device
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {ControllersDevicesActivateDeviceRequest} payload Activation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdActivatePost(groupId: number, deviceId: string, payload: ControllersDevicesActivateDeviceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersDevicesDeviceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdActivatePost(groupId, deviceId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdActivatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a specific device by ID
         * @summary Get a device
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdGet(groupId: number, deviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersDevicesDeviceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdGet(groupId, deviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the last seen timestamp for a device
         * @summary Update device heartbeat
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdHeartbeatPost(groupId: number, deviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdHeartbeatPost(groupId, deviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdHeartbeatPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the encrypted group key for a device (if updated during rotation)
         * @summary Get device\'s encrypted group key
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdKeyGet(groupId: number, deviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdKeyGet(groupId, deviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdKeyGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the public key for a device. Used for key migration scenarios.
         * @summary Update device public key
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {ControllersDevicesUpdatePublicKeyRequest} payload Public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPublicKeyPut(groupId: number, deviceId: string, payload: ControllersDevicesUpdatePublicKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPublicKeyPut(groupId, deviceId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPublicKeyPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Clears the push notification token for a device
         * @summary Clear device push token
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenDelete(groupId: number, deviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenDelete(groupId, deviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the push notification token for a device
         * @summary Update device push token
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {ControllersDevicesUpdatePushTokenRequest} payload Push token payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenPut(groupId: number, deviceId: string, payload: ControllersDevicesUpdatePushTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenPut(groupId, deviceId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Opens an SSE connection to receive real-time device events for a group
         * @summary Subscribe to group device events
         * @param {number} groupId Group ID
         * @param {string} [deviceId] Device ID (optional, for device-specific events)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdDevicesEventsGet(groupId: number, deviceId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersDevicesSSEMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdDevicesEventsGet(groupId, deviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdDevicesEventsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all devices registered in a group
         * @summary List devices in a group
         * @param {number} groupId Group ID
         * @param {string} [status] Filter by status (active, pending, revoked)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdDevicesGet(groupId: number, status?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ControllersDevicesDeviceResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdDevicesGet(groupId, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdDevicesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all pending key requests for a group
         * @summary List pending key requests
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsGet(groupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ControllersDevicesKeyRequestResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a request to receive the encrypted group key from another device
         * @summary Create a key sharing request
         * @param {number} groupId Group ID
         * @param {ControllersDevicesCreateKeyRequestRequest} payload Key request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsPost(groupId: number, payload: ControllersDevicesCreateKeyRequestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersDevicesKeyRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsPost(groupId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a specific key request by ID
         * @summary Get a key request
         * @param {number} groupId Group ID
         * @param {string} requestId Request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGet(groupId: number, requestId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersDevicesKeyRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGet(groupId, requestId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Grants a key request by providing the encrypted group key
         * @summary Grant a key request
         * @param {number} groupId Group ID
         * @param {string} requestId Request ID
         * @param {ControllersDevicesGrantKeyRequestRequest} payload Grant payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGrantPost(groupId: number, requestId: string, payload: ControllersDevicesGrantKeyRequestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGrantPost(groupId, requestId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGrantPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rejects a pending key request
         * @summary Reject a key request
         * @param {number} groupId Group ID
         * @param {string} requestId Request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdRejectPost(groupId: number, requestId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdRejectPost(groupId, requestId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdRejectPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Registers a new device for the current user in a group
         * @summary Register a new device
         * @param {number} groupId Group ID
         * @param {ControllersDevicesRegisterDeviceRequest} payload Device registration payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdDevicesPost(groupId: number, payload: ControllersDevicesRegisterDeviceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersDevicesDeviceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdDevicesPost(groupId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdDevicesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets real-time presence information for all devices in a group
         * @summary Get device presence
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdDevicesPresenceGet(groupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupDevicePresenceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdDevicesPresenceGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdDevicesPresenceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns current key version and whether device needs update
         * @summary Get key version info
         * @param {number} groupId Group ID
         * @param {string} [deviceId] Device ID (optional, uses current user\&#39;s device if not specified)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdKeysVersionGet(groupId: number, deviceId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonKeyVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdKeysVersionGet(groupId, deviceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.authlanceIdentityApiV1RealmGroupsGroupIdKeysVersionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * Removes a device from the group (admin only)
         * @summary Remove a device
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdDelete(groupId: number, deviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdDelete(groupId, deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Revokes a device (admin only). Optionally includes rotation data to atomically revoke and rotate.
         * @summary Revoke a device
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {ControllersDevicesRevokeWithRotationRequest} [payload] Optional rotation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdRevokePost(groupId: number, deviceId: string, payload?: ControllersDevicesRevokeWithRotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonKeyRotationResponse> {
            return localVarFp.authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdRevokePost(groupId, deviceId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Rotates the group key and re-encrypts secrets (admin only)
         * @summary Rotate group encryption key
         * @param {number} groupId Group ID
         * @param {ControllersDevicesRotateKeyRequest} payload Rotation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupsGroupIdKeysRotatePost(groupId: number, payload: ControllersDevicesRotateKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonKeyRotationResponse> {
            return localVarFp.authlanceIdentityApiV1RealmAdminGroupsGroupIdKeysRotatePost(groupId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the count of active devices in a group (for subscription enforcement)
         * @summary Get device count
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesCountGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonDeviceLimitReachedResponse> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdDevicesCountGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates a device with its encrypted group key
         * @summary Activate a device
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {ControllersDevicesActivateDeviceRequest} payload Activation payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdActivatePost(groupId: number, deviceId: string, payload: ControllersDevicesActivateDeviceRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesDeviceResponse> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdActivatePost(groupId, deviceId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific device by ID
         * @summary Get a device
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdGet(groupId: number, deviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesDeviceResponse> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdGet(groupId, deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the last seen timestamp for a device
         * @summary Update device heartbeat
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdHeartbeatPost(groupId: number, deviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdHeartbeatPost(groupId, deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the encrypted group key for a device (if updated during rotation)
         * @summary Get device\'s encrypted group key
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdKeyGet(groupId: number, deviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdKeyGet(groupId, deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the public key for a device. Used for key migration scenarios.
         * @summary Update device public key
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {ControllersDevicesUpdatePublicKeyRequest} payload Public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPublicKeyPut(groupId: number, deviceId: string, payload: ControllersDevicesUpdatePublicKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPublicKeyPut(groupId, deviceId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Clears the push notification token for a device
         * @summary Clear device push token
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenDelete(groupId: number, deviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenDelete(groupId, deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the push notification token for a device
         * @summary Update device push token
         * @param {number} groupId Group ID
         * @param {string} deviceId Device ID
         * @param {ControllersDevicesUpdatePushTokenRequest} payload Push token payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenPut(groupId: number, deviceId: string, payload: ControllersDevicesUpdatePushTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenPut(groupId, deviceId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Opens an SSE connection to receive real-time device events for a group
         * @summary Subscribe to group device events
         * @param {number} groupId Group ID
         * @param {string} [deviceId] Device ID (optional, for device-specific events)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesEventsGet(groupId: number, deviceId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesSSEMessage> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdDevicesEventsGet(groupId, deviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all devices registered in a group
         * @summary List devices in a group
         * @param {number} groupId Group ID
         * @param {string} [status] Filter by status (active, pending, revoked)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesGet(groupId: number, status?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ControllersDevicesDeviceResponse>> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdDevicesGet(groupId, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all pending key requests for a group
         * @summary List pending key requests
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ControllersDevicesKeyRequestResponse>> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a request to receive the encrypted group key from another device
         * @summary Create a key sharing request
         * @param {number} groupId Group ID
         * @param {ControllersDevicesCreateKeyRequestRequest} payload Key request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsPost(groupId: number, payload: ControllersDevicesCreateKeyRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesKeyRequestResponse> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsPost(groupId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific key request by ID
         * @summary Get a key request
         * @param {number} groupId Group ID
         * @param {string} requestId Request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGet(groupId: number, requestId: string, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesKeyRequestResponse> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGet(groupId, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Grants a key request by providing the encrypted group key
         * @summary Grant a key request
         * @param {number} groupId Group ID
         * @param {string} requestId Request ID
         * @param {ControllersDevicesGrantKeyRequestRequest} payload Grant payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGrantPost(groupId: number, requestId: string, payload: ControllersDevicesGrantKeyRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGrantPost(groupId, requestId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Rejects a pending key request
         * @summary Reject a key request
         * @param {number} groupId Group ID
         * @param {string} requestId Request ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdRejectPost(groupId: number, requestId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdRejectPost(groupId, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a new device for the current user in a group
         * @summary Register a new device
         * @param {number} groupId Group ID
         * @param {ControllersDevicesRegisterDeviceRequest} payload Device registration payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesPost(groupId: number, payload: ControllersDevicesRegisterDeviceRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesDeviceResponse> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdDevicesPost(groupId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets real-time presence information for all devices in a group
         * @summary Get device presence
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdDevicesPresenceGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupDevicePresenceResponse> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdDevicesPresenceGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns current key version and whether device needs update
         * @summary Get key version info
         * @param {number} groupId Group ID
         * @param {string} [deviceId] Device ID (optional, uses current user\&#39;s device if not specified)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdKeysVersionGet(groupId: number, deviceId?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonKeyVersionResponse> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdKeysVersionGet(groupId, deviceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - interface
 * @export
 * @interface DevicesApi
 */
export interface DevicesApiInterface {
    /**
     * Removes a device from the group (admin only)
     * @summary Remove a device
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdDelete(groupId: number, deviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Revokes a device (admin only). Optionally includes rotation data to atomically revoke and rotate.
     * @summary Revoke a device
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {ControllersDevicesRevokeWithRotationRequest} [payload] Optional rotation payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdRevokePost(groupId: number, deviceId: string, payload?: ControllersDevicesRevokeWithRotationRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonKeyRotationResponse>;

    /**
     * Rotates the group key and re-encrypts secrets (admin only)
     * @summary Rotate group encryption key
     * @param {number} groupId Group ID
     * @param {ControllersDevicesRotateKeyRequest} payload Rotation payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmAdminGroupsGroupIdKeysRotatePost(groupId: number, payload: ControllersDevicesRotateKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonKeyRotationResponse>;

    /**
     * Gets the count of active devices in a group (for subscription enforcement)
     * @summary Get device count
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdDevicesCountGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonDeviceLimitReachedResponse>;

    /**
     * Activates a device with its encrypted group key
     * @summary Activate a device
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {ControllersDevicesActivateDeviceRequest} payload Activation payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdActivatePost(groupId: number, deviceId: string, payload: ControllersDevicesActivateDeviceRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesDeviceResponse>;

    /**
     * Gets a specific device by ID
     * @summary Get a device
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdGet(groupId: number, deviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesDeviceResponse>;

    /**
     * Updates the last seen timestamp for a device
     * @summary Update device heartbeat
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdHeartbeatPost(groupId: number, deviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Returns the encrypted group key for a device (if updated during rotation)
     * @summary Get device\'s encrypted group key
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdKeyGet(groupId: number, deviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }>;

    /**
     * Updates the public key for a device. Used for key migration scenarios.
     * @summary Update device public key
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {ControllersDevicesUpdatePublicKeyRequest} payload Public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPublicKeyPut(groupId: number, deviceId: string, payload: ControllersDevicesUpdatePublicKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Clears the push notification token for a device
     * @summary Clear device push token
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenDelete(groupId: number, deviceId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Updates the push notification token for a device
     * @summary Update device push token
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {ControllersDevicesUpdatePushTokenRequest} payload Push token payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenPut(groupId: number, deviceId: string, payload: ControllersDevicesUpdatePushTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Opens an SSE connection to receive real-time device events for a group
     * @summary Subscribe to group device events
     * @param {number} groupId Group ID
     * @param {string} [deviceId] Device ID (optional, for device-specific events)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdDevicesEventsGet(groupId: number, deviceId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesSSEMessage>;

    /**
     * Lists all devices registered in a group
     * @summary List devices in a group
     * @param {number} groupId Group ID
     * @param {string} [status] Filter by status (active, pending, revoked)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdDevicesGet(groupId: number, status?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ControllersDevicesDeviceResponse>>;

    /**
     * Lists all pending key requests for a group
     * @summary List pending key requests
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ControllersDevicesKeyRequestResponse>>;

    /**
     * Creates a request to receive the encrypted group key from another device
     * @summary Create a key sharing request
     * @param {number} groupId Group ID
     * @param {ControllersDevicesCreateKeyRequestRequest} payload Key request payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsPost(groupId: number, payload: ControllersDevicesCreateKeyRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesKeyRequestResponse>;

    /**
     * Gets a specific key request by ID
     * @summary Get a key request
     * @param {number} groupId Group ID
     * @param {string} requestId Request ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGet(groupId: number, requestId: string, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesKeyRequestResponse>;

    /**
     * Grants a key request by providing the encrypted group key
     * @summary Grant a key request
     * @param {number} groupId Group ID
     * @param {string} requestId Request ID
     * @param {ControllersDevicesGrantKeyRequestRequest} payload Grant payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGrantPost(groupId: number, requestId: string, payload: ControllersDevicesGrantKeyRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Rejects a pending key request
     * @summary Reject a key request
     * @param {number} groupId Group ID
     * @param {string} requestId Request ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdRejectPost(groupId: number, requestId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Registers a new device for the current user in a group
     * @summary Register a new device
     * @param {number} groupId Group ID
     * @param {ControllersDevicesRegisterDeviceRequest} payload Device registration payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdDevicesPost(groupId: number, payload: ControllersDevicesRegisterDeviceRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesDeviceResponse>;

    /**
     * Gets real-time presence information for all devices in a group
     * @summary Get device presence
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdDevicesPresenceGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupDevicePresenceResponse>;

    /**
     * Returns current key version and whether device needs update
     * @summary Get key version info
     * @param {number} groupId Group ID
     * @param {string} [deviceId] Device ID (optional, uses current user\&#39;s device if not specified)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdKeysVersionGet(groupId: number, deviceId?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonKeyVersionResponse>;

}

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI implements DevicesApiInterface {
    /**
     * Removes a device from the group (admin only)
     * @summary Remove a device
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdDelete(groupId: number, deviceId: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdDelete(groupId, deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revokes a device (admin only). Optionally includes rotation data to atomically revoke and rotate.
     * @summary Revoke a device
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {ControllersDevicesRevokeWithRotationRequest} [payload] Optional rotation payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdRevokePost(groupId: number, deviceId: string, payload?: ControllersDevicesRevokeWithRotationRequest, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmAdminGroupsGroupIdDevicesDeviceIdRevokePost(groupId, deviceId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rotates the group key and re-encrypts secrets (admin only)
     * @summary Rotate group encryption key
     * @param {number} groupId Group ID
     * @param {ControllersDevicesRotateKeyRequest} payload Rotation payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmAdminGroupsGroupIdKeysRotatePost(groupId: number, payload: ControllersDevicesRotateKeyRequest, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmAdminGroupsGroupIdKeysRotatePost(groupId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the count of active devices in a group (for subscription enforcement)
     * @summary Get device count
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdDevicesCountGet(groupId: number, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdDevicesCountGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activates a device with its encrypted group key
     * @summary Activate a device
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {ControllersDevicesActivateDeviceRequest} payload Activation payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdActivatePost(groupId: number, deviceId: string, payload: ControllersDevicesActivateDeviceRequest, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdActivatePost(groupId, deviceId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific device by ID
     * @summary Get a device
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdGet(groupId: number, deviceId: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdGet(groupId, deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the last seen timestamp for a device
     * @summary Update device heartbeat
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdHeartbeatPost(groupId: number, deviceId: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdHeartbeatPost(groupId, deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the encrypted group key for a device (if updated during rotation)
     * @summary Get device\'s encrypted group key
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdKeyGet(groupId: number, deviceId: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdKeyGet(groupId, deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the public key for a device. Used for key migration scenarios.
     * @summary Update device public key
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {ControllersDevicesUpdatePublicKeyRequest} payload Public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPublicKeyPut(groupId: number, deviceId: string, payload: ControllersDevicesUpdatePublicKeyRequest, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPublicKeyPut(groupId, deviceId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clears the push notification token for a device
     * @summary Clear device push token
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenDelete(groupId: number, deviceId: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenDelete(groupId, deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the push notification token for a device
     * @summary Update device push token
     * @param {number} groupId Group ID
     * @param {string} deviceId Device ID
     * @param {ControllersDevicesUpdatePushTokenRequest} payload Push token payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenPut(groupId: number, deviceId: string, payload: ControllersDevicesUpdatePushTokenRequest, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdDevicesDeviceIdPushTokenPut(groupId, deviceId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Opens an SSE connection to receive real-time device events for a group
     * @summary Subscribe to group device events
     * @param {number} groupId Group ID
     * @param {string} [deviceId] Device ID (optional, for device-specific events)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdDevicesEventsGet(groupId: number, deviceId?: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdDevicesEventsGet(groupId, deviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all devices registered in a group
     * @summary List devices in a group
     * @param {number} groupId Group ID
     * @param {string} [status] Filter by status (active, pending, revoked)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdDevicesGet(groupId: number, status?: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdDevicesGet(groupId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all pending key requests for a group
     * @summary List pending key requests
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsGet(groupId: number, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a request to receive the encrypted group key from another device
     * @summary Create a key sharing request
     * @param {number} groupId Group ID
     * @param {ControllersDevicesCreateKeyRequestRequest} payload Key request payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsPost(groupId: number, payload: ControllersDevicesCreateKeyRequestRequest, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsPost(groupId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific key request by ID
     * @summary Get a key request
     * @param {number} groupId Group ID
     * @param {string} requestId Request ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGet(groupId: number, requestId: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGet(groupId, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Grants a key request by providing the encrypted group key
     * @summary Grant a key request
     * @param {number} groupId Group ID
     * @param {string} requestId Request ID
     * @param {ControllersDevicesGrantKeyRequestRequest} payload Grant payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGrantPost(groupId: number, requestId: string, payload: ControllersDevicesGrantKeyRequestRequest, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdGrantPost(groupId, requestId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rejects a pending key request
     * @summary Reject a key request
     * @param {number} groupId Group ID
     * @param {string} requestId Request ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdRejectPost(groupId: number, requestId: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdDevicesKeyRequestsRequestIdRejectPost(groupId, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a new device for the current user in a group
     * @summary Register a new device
     * @param {number} groupId Group ID
     * @param {ControllersDevicesRegisterDeviceRequest} payload Device registration payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdDevicesPost(groupId: number, payload: ControllersDevicesRegisterDeviceRequest, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdDevicesPost(groupId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets real-time presence information for all devices in a group
     * @summary Get device presence
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdDevicesPresenceGet(groupId: number, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdDevicesPresenceGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns current key version and whether device needs update
     * @summary Get key version info
     * @param {number} groupId Group ID
     * @param {string} [deviceId] Device ID (optional, uses current user\&#39;s device if not specified)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdKeysVersionGet(groupId: number, deviceId?: string, options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdKeysVersionGet(groupId, deviceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LicenseApi - axios parameter creator
 * @export
 */
export const LicenseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Forces the license manager to reload the license file immediately (requires sysadmin privileges).
         * @summary Reload license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminLicenseReloadPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/identity/api/v1/admin/license/reload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current evaluated license status (requires sysadmin privileges).
         * @summary Get license status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminLicenseStatusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/identity/api/v1/admin/license/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Persists a new license payload and reloads the active license status (requires sysadmin privileges).
         * @summary Update license
         * @param {ControllersLicenseUpdateLicenseRequest} payload License payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminLicenseValuePut: async (payload: ControllersLicenseUpdateLicenseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1AdminLicenseValuePut', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/admin/license/value`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LicenseApi - functional programming interface
 * @export
 */
export const LicenseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LicenseApiAxiosParamCreator(configuration)
    return {
        /**
         * Forces the license manager to reload the license file immediately (requires sysadmin privileges).
         * @summary Reload license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminLicenseReloadPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersLicenseLicenseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminLicenseReloadPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseApi.authlanceIdentityApiV1AdminLicenseReloadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the current evaluated license status (requires sysadmin privileges).
         * @summary Get license status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminLicenseStatusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersLicenseLicenseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminLicenseStatusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseApi.authlanceIdentityApiV1AdminLicenseStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Persists a new license payload and reloads the active license status (requires sysadmin privileges).
         * @summary Update license
         * @param {ControllersLicenseUpdateLicenseRequest} payload License payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1AdminLicenseValuePut(payload: ControllersLicenseUpdateLicenseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersLicenseLicenseStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1AdminLicenseValuePut(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseApi.authlanceIdentityApiV1AdminLicenseValuePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LicenseApi - factory interface
 * @export
 */
export const LicenseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LicenseApiFp(configuration)
    return {
        /**
         * Forces the license manager to reload the license file immediately (requires sysadmin privileges).
         * @summary Reload license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminLicenseReloadPost(options?: RawAxiosRequestConfig): AxiosPromise<ControllersLicenseLicenseStatusResponse> {
            return localVarFp.authlanceIdentityApiV1AdminLicenseReloadPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current evaluated license status (requires sysadmin privileges).
         * @summary Get license status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminLicenseStatusGet(options?: RawAxiosRequestConfig): AxiosPromise<ControllersLicenseLicenseStatusResponse> {
            return localVarFp.authlanceIdentityApiV1AdminLicenseStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Persists a new license payload and reloads the active license status (requires sysadmin privileges).
         * @summary Update license
         * @param {ControllersLicenseUpdateLicenseRequest} payload License payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1AdminLicenseValuePut(payload: ControllersLicenseUpdateLicenseRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersLicenseLicenseStatusResponse> {
            return localVarFp.authlanceIdentityApiV1AdminLicenseValuePut(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LicenseApi - interface
 * @export
 * @interface LicenseApi
 */
export interface LicenseApiInterface {
    /**
     * Forces the license manager to reload the license file immediately (requires sysadmin privileges).
     * @summary Reload license
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApiInterface
     */
    authlanceIdentityApiV1AdminLicenseReloadPost(options?: RawAxiosRequestConfig): AxiosPromise<ControllersLicenseLicenseStatusResponse>;

    /**
     * Returns the current evaluated license status (requires sysadmin privileges).
     * @summary Get license status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApiInterface
     */
    authlanceIdentityApiV1AdminLicenseStatusGet(options?: RawAxiosRequestConfig): AxiosPromise<ControllersLicenseLicenseStatusResponse>;

    /**
     * Persists a new license payload and reloads the active license status (requires sysadmin privileges).
     * @summary Update license
     * @param {ControllersLicenseUpdateLicenseRequest} payload License payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApiInterface
     */
    authlanceIdentityApiV1AdminLicenseValuePut(payload: ControllersLicenseUpdateLicenseRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersLicenseLicenseStatusResponse>;

}

/**
 * LicenseApi - object-oriented interface
 * @export
 * @class LicenseApi
 * @extends {BaseAPI}
 */
export class LicenseApi extends BaseAPI implements LicenseApiInterface {
    /**
     * Forces the license manager to reload the license file immediately (requires sysadmin privileges).
     * @summary Reload license
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public authlanceIdentityApiV1AdminLicenseReloadPost(options?: RawAxiosRequestConfig) {
        return LicenseApiFp(this.configuration).authlanceIdentityApiV1AdminLicenseReloadPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current evaluated license status (requires sysadmin privileges).
     * @summary Get license status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public authlanceIdentityApiV1AdminLicenseStatusGet(options?: RawAxiosRequestConfig) {
        return LicenseApiFp(this.configuration).authlanceIdentityApiV1AdminLicenseStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Persists a new license payload and reloads the active license status (requires sysadmin privileges).
     * @summary Update license
     * @param {ControllersLicenseUpdateLicenseRequest} payload License payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public authlanceIdentityApiV1AdminLicenseValuePut(payload: ControllersLicenseUpdateLicenseRequest, options?: RawAxiosRequestConfig) {
        return LicenseApiFp(this.configuration).authlanceIdentityApiV1AdminLicenseValuePut(payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Stripe checkout session for subscription payment
         * @summary Create checkout session
         * @param {DunaAuthCommonCreateCheckoutSessionRequest} request Checkout session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1CheckoutSessionPost: async (request: DunaAuthCommonCreateCheckoutSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authlancePaymentsApiV1CheckoutSessionPost', 'request', request)
            const localVarPath = `/authlance/payments/api/v1/checkout-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Stripe customer portal session for subscription management
         * @summary Create customer portal session
         * @param {DunaAuthCommonCreateCustomerPortalSessionRequest} request Portal session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1CustomerPortalPost: async (request: DunaAuthCommonCreateCustomerPortalSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authlancePaymentsApiV1CustomerPortalPost', 'request', request)
            const localVarPath = `/authlance/payments/api/v1/customer-portal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves Stripe product details by lookup key
         * @summary Get product details
         * @param {DunaAuthCommonGetProductDetailsRequest} request Product details request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1ProductDetailsPost: async (request: DunaAuthCommonGetProductDetailsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authlancePaymentsApiV1ProductDetailsPost', 'request', request)
            const localVarPath = `/authlance/payments/api/v1/product-details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the subscription ID from a checkout session
         * @summary Get subscription from session
         * @param {DunaAuthCommonGetSubscriptionSessionRequest} request Session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1SessionIdPost: async (request: DunaAuthCommonGetSubscriptionSessionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('authlancePaymentsApiV1SessionIdPost', 'request', request)
            const localVarPath = `/authlance/payments/api/v1/session-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Processes Stripe webhook events
         * @summary Handle Stripe webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1StripeWebhookPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/payments/api/v1/stripe/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new Stripe checkout session for subscription payment
         * @summary Create checkout session
         * @param {DunaAuthCommonCreateCheckoutSessionRequest} request Checkout session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlancePaymentsApiV1CheckoutSessionPost(request: DunaAuthCommonCreateCheckoutSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonCreateCheckoutSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlancePaymentsApiV1CheckoutSessionPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.authlancePaymentsApiV1CheckoutSessionPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Stripe customer portal session for subscription management
         * @summary Create customer portal session
         * @param {DunaAuthCommonCreateCustomerPortalSessionRequest} request Portal session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlancePaymentsApiV1CustomerPortalPost(request: DunaAuthCommonCreateCustomerPortalSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonCreateCustomerPortalSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlancePaymentsApiV1CustomerPortalPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.authlancePaymentsApiV1CustomerPortalPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves Stripe product details by lookup key
         * @summary Get product details
         * @param {DunaAuthCommonGetProductDetailsRequest} request Product details request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlancePaymentsApiV1ProductDetailsPost(request: DunaAuthCommonGetProductDetailsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGetProductDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlancePaymentsApiV1ProductDetailsPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.authlancePaymentsApiV1ProductDetailsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the subscription ID from a checkout session
         * @summary Get subscription from session
         * @param {DunaAuthCommonGetSubscriptionSessionRequest} request Session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlancePaymentsApiV1SessionIdPost(request: DunaAuthCommonGetSubscriptionSessionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGetSubscriptionSessionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlancePaymentsApiV1SessionIdPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.authlancePaymentsApiV1SessionIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Processes Stripe webhook events
         * @summary Handle Stripe webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlancePaymentsApiV1StripeWebhookPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlancePaymentsApiV1StripeWebhookPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.authlancePaymentsApiV1StripeWebhookPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * Creates a new Stripe checkout session for subscription payment
         * @summary Create checkout session
         * @param {DunaAuthCommonCreateCheckoutSessionRequest} request Checkout session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1CheckoutSessionPost(request: DunaAuthCommonCreateCheckoutSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonCreateCheckoutSessionResponse> {
            return localVarFp.authlancePaymentsApiV1CheckoutSessionPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Stripe customer portal session for subscription management
         * @summary Create customer portal session
         * @param {DunaAuthCommonCreateCustomerPortalSessionRequest} request Portal session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1CustomerPortalPost(request: DunaAuthCommonCreateCustomerPortalSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonCreateCustomerPortalSessionResponse> {
            return localVarFp.authlancePaymentsApiV1CustomerPortalPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves Stripe product details by lookup key
         * @summary Get product details
         * @param {DunaAuthCommonGetProductDetailsRequest} request Product details request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1ProductDetailsPost(request: DunaAuthCommonGetProductDetailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGetProductDetailsResponse> {
            return localVarFp.authlancePaymentsApiV1ProductDetailsPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the subscription ID from a checkout session
         * @summary Get subscription from session
         * @param {DunaAuthCommonGetSubscriptionSessionRequest} request Session request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1SessionIdPost(request: DunaAuthCommonGetSubscriptionSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGetSubscriptionSessionResponse> {
            return localVarFp.authlancePaymentsApiV1SessionIdPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Processes Stripe webhook events
         * @summary Handle Stripe webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlancePaymentsApiV1StripeWebhookPost(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.authlancePaymentsApiV1StripeWebhookPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - interface
 * @export
 * @interface PaymentsApi
 */
export interface PaymentsApiInterface {
    /**
     * Creates a new Stripe checkout session for subscription payment
     * @summary Create checkout session
     * @param {DunaAuthCommonCreateCheckoutSessionRequest} request Checkout session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApiInterface
     */
    authlancePaymentsApiV1CheckoutSessionPost(request: DunaAuthCommonCreateCheckoutSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonCreateCheckoutSessionResponse>;

    /**
     * Creates a Stripe customer portal session for subscription management
     * @summary Create customer portal session
     * @param {DunaAuthCommonCreateCustomerPortalSessionRequest} request Portal session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApiInterface
     */
    authlancePaymentsApiV1CustomerPortalPost(request: DunaAuthCommonCreateCustomerPortalSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonCreateCustomerPortalSessionResponse>;

    /**
     * Retrieves Stripe product details by lookup key
     * @summary Get product details
     * @param {DunaAuthCommonGetProductDetailsRequest} request Product details request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApiInterface
     */
    authlancePaymentsApiV1ProductDetailsPost(request: DunaAuthCommonGetProductDetailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGetProductDetailsResponse>;

    /**
     * Retrieves the subscription ID from a checkout session
     * @summary Get subscription from session
     * @param {DunaAuthCommonGetSubscriptionSessionRequest} request Session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApiInterface
     */
    authlancePaymentsApiV1SessionIdPost(request: DunaAuthCommonGetSubscriptionSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGetSubscriptionSessionResponse>;

    /**
     * Processes Stripe webhook events
     * @summary Handle Stripe webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApiInterface
     */
    authlancePaymentsApiV1StripeWebhookPost(options?: RawAxiosRequestConfig): AxiosPromise<string>;

}

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI implements PaymentsApiInterface {
    /**
     * Creates a new Stripe checkout session for subscription payment
     * @summary Create checkout session
     * @param {DunaAuthCommonCreateCheckoutSessionRequest} request Checkout session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public authlancePaymentsApiV1CheckoutSessionPost(request: DunaAuthCommonCreateCheckoutSessionRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).authlancePaymentsApiV1CheckoutSessionPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Stripe customer portal session for subscription management
     * @summary Create customer portal session
     * @param {DunaAuthCommonCreateCustomerPortalSessionRequest} request Portal session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public authlancePaymentsApiV1CustomerPortalPost(request: DunaAuthCommonCreateCustomerPortalSessionRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).authlancePaymentsApiV1CustomerPortalPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves Stripe product details by lookup key
     * @summary Get product details
     * @param {DunaAuthCommonGetProductDetailsRequest} request Product details request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public authlancePaymentsApiV1ProductDetailsPost(request: DunaAuthCommonGetProductDetailsRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).authlancePaymentsApiV1ProductDetailsPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the subscription ID from a checkout session
     * @summary Get subscription from session
     * @param {DunaAuthCommonGetSubscriptionSessionRequest} request Session request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public authlancePaymentsApiV1SessionIdPost(request: DunaAuthCommonGetSubscriptionSessionRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).authlancePaymentsApiV1SessionIdPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Processes Stripe webhook events
     * @summary Handle Stripe webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public authlancePaymentsApiV1StripeWebhookPost(options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).authlancePaymentsApiV1StripeWebhookPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PersonalAccessTokensApi - axios parameter creator
 * @export
 */
export const PersonalAccessTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lists personal access tokens for the specified group.
         * @summary List personal access tokens for a group
         * @param {number} groupId Group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1PatsGet: async (groupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1PatsGet', 'groupId', groupId)
            const localVarPath = `/authlance/identity/api/v1/pats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new personal access token for a group and returns the token value once.
         * @summary Create personal access token
         * @param {ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest} payload Personal access token payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1PatsPost: async (payload: ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1PatsPost', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/pats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revokes a personal access token by setting its revokedAt timestamp.
         * @summary Revoke personal access token
         * @param {string} tokenId Token identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1PatsTokenIdDelete: async (tokenId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1PatsTokenIdDelete', 'tokenId', tokenId)
            const localVarPath = `/authlance/identity/api/v1/pats/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies whether a personal access token is valid and returns its metadata.
         * @summary Verify personal access token
         * @param {string} [authorization] Bearer pat_&lt;prefix&gt;-&lt;secret&gt;
         * @param {ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest} [payload] Verification payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1PatsVerifyPost: async (authorization?: string, payload?: ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/identity/api/v1/pats/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonalAccessTokensApi - functional programming interface
 * @export
 */
export const PersonalAccessTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonalAccessTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * Lists personal access tokens for the specified group.
         * @summary List personal access tokens for a group
         * @param {number} groupId Group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1PatsGet(groupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ControllersPersonalaccesstokensPersonalAccessTokenResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1PatsGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonalAccessTokensApi.authlanceIdentityApiV1PatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new personal access token for a group and returns the token value once.
         * @summary Create personal access token
         * @param {ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest} payload Personal access token payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1PatsPost(payload: ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersPersonalaccesstokensPersonalAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1PatsPost(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonalAccessTokensApi.authlanceIdentityApiV1PatsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revokes a personal access token by setting its revokedAt timestamp.
         * @summary Revoke personal access token
         * @param {string} tokenId Token identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1PatsTokenIdDelete(tokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1PatsTokenIdDelete(tokenId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonalAccessTokensApi.authlanceIdentityApiV1PatsTokenIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies whether a personal access token is valid and returns its metadata.
         * @summary Verify personal access token
         * @param {string} [authorization] Bearer pat_&lt;prefix&gt;-&lt;secret&gt;
         * @param {ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest} [payload] Verification payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1PatsVerifyPost(authorization?: string, payload?: ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1PatsVerifyPost(authorization, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonalAccessTokensApi.authlanceIdentityApiV1PatsVerifyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PersonalAccessTokensApi - factory interface
 * @export
 */
export const PersonalAccessTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonalAccessTokensApiFp(configuration)
    return {
        /**
         * Lists personal access tokens for the specified group.
         * @summary List personal access tokens for a group
         * @param {number} groupId Group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1PatsGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ControllersPersonalaccesstokensPersonalAccessTokenResponse>> {
            return localVarFp.authlanceIdentityApiV1PatsGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new personal access token for a group and returns the token value once.
         * @summary Create personal access token
         * @param {ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest} payload Personal access token payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1PatsPost(payload: ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersPersonalaccesstokensPersonalAccessTokenResponse> {
            return localVarFp.authlanceIdentityApiV1PatsPost(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Revokes a personal access token by setting its revokedAt timestamp.
         * @summary Revoke personal access token
         * @param {string} tokenId Token identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1PatsTokenIdDelete(tokenId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authlanceIdentityApiV1PatsTokenIdDelete(tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies whether a personal access token is valid and returns its metadata.
         * @summary Verify personal access token
         * @param {string} [authorization] Bearer pat_&lt;prefix&gt;-&lt;secret&gt;
         * @param {ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest} [payload] Verification payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1PatsVerifyPost(authorization?: string, payload?: ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse> {
            return localVarFp.authlanceIdentityApiV1PatsVerifyPost(authorization, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonalAccessTokensApi - interface
 * @export
 * @interface PersonalAccessTokensApi
 */
export interface PersonalAccessTokensApiInterface {
    /**
     * Lists personal access tokens for the specified group.
     * @summary List personal access tokens for a group
     * @param {number} groupId Group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApiInterface
     */
    authlanceIdentityApiV1PatsGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ControllersPersonalaccesstokensPersonalAccessTokenResponse>>;

    /**
     * Creates a new personal access token for a group and returns the token value once.
     * @summary Create personal access token
     * @param {ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest} payload Personal access token payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApiInterface
     */
    authlanceIdentityApiV1PatsPost(payload: ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersPersonalaccesstokensPersonalAccessTokenResponse>;

    /**
     * Revokes a personal access token by setting its revokedAt timestamp.
     * @summary Revoke personal access token
     * @param {string} tokenId Token identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApiInterface
     */
    authlanceIdentityApiV1PatsTokenIdDelete(tokenId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Verifies whether a personal access token is valid and returns its metadata.
     * @summary Verify personal access token
     * @param {string} [authorization] Bearer pat_&lt;prefix&gt;-&lt;secret&gt;
     * @param {ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest} [payload] Verification payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApiInterface
     */
    authlanceIdentityApiV1PatsVerifyPost(authorization?: string, payload?: ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersPersonalaccesstokensVerifyPersonalAccessTokenResponse>;

}

/**
 * PersonalAccessTokensApi - object-oriented interface
 * @export
 * @class PersonalAccessTokensApi
 * @extends {BaseAPI}
 */
export class PersonalAccessTokensApi extends BaseAPI implements PersonalAccessTokensApiInterface {
    /**
     * Lists personal access tokens for the specified group.
     * @summary List personal access tokens for a group
     * @param {number} groupId Group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public authlanceIdentityApiV1PatsGet(groupId: number, options?: RawAxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).authlanceIdentityApiV1PatsGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new personal access token for a group and returns the token value once.
     * @summary Create personal access token
     * @param {ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest} payload Personal access token payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public authlanceIdentityApiV1PatsPost(payload: ControllersPersonalaccesstokensCreatePersonalAccessTokenRequest, options?: RawAxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).authlanceIdentityApiV1PatsPost(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revokes a personal access token by setting its revokedAt timestamp.
     * @summary Revoke personal access token
     * @param {string} tokenId Token identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public authlanceIdentityApiV1PatsTokenIdDelete(tokenId: string, options?: RawAxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).authlanceIdentityApiV1PatsTokenIdDelete(tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies whether a personal access token is valid and returns its metadata.
     * @summary Verify personal access token
     * @param {string} [authorization] Bearer pat_&lt;prefix&gt;-&lt;secret&gt;
     * @param {ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest} [payload] Verification payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonalAccessTokensApi
     */
    public authlanceIdentityApiV1PatsVerifyPost(authorization?: string, payload?: ControllersPersonalaccesstokensVerifyPersonalAccessTokenRequest, options?: RawAxiosRequestConfig) {
        return PersonalAccessTokensApiFp(this.configuration).authlanceIdentityApiV1PatsVerifyPost(authorization, payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Updates the authenticated user\'s profile. JSON payloads update the basic attributes and multipart bodies may include an avatar upload.
         * @summary Update current profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileMePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/identity/api/v1/profile/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies if a group slug is free before the authenticated user attempts to create or join it.
         * @summary Check if a group name is available
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet: async (group: string, user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet', 'group', group)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet', 'user', user)
            const localVarPath = `/authlance/identity/api/v1/profile/my-group/{group}/{user}/available`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paginated platform roles that the authenticated user can request within their groups.
         * @summary List available roles for current context
         * @param {string} user User identity
         * @param {number} page Page number
         * @param {number} [perPage] Page size
         * @param {string} [filter] Text filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet: async (user: string, page: number, perPage?: number, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet', 'user', user)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet', 'page', page)
            const localVarPath = `/authlance/identity/api/v1/profile/my-group/roles/{user}/{page}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns every group that belongs to the authenticated identity. The `{user}` parameter is kept for compatibility and is ignored.
         * @summary List authenticated user\'s groups
         * @param {string} user Compatibility placeholder (use \&#39;me\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileMyGroupsUserGet: async (user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileMyGroupsUserGet', 'user', user)
            const localVarPath = `/authlance/identity/api/v1/profile/my-groups/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * Updates the authenticated user\'s profile. JSON payloads update the basic attributes and multipart bodies may include an avatar upload.
         * @summary Update current profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1ProfileMePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1ProfileMePost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.authlanceIdentityApiV1ProfileMePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies if a group slug is free before the authenticated user attempts to create or join it.
         * @summary Check if a group name is available
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet(group: string, user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupAvailabilityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet(group, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns paginated platform roles that the authenticated user can request within their groups.
         * @summary List available roles for current context
         * @param {string} user User identity
         * @param {number} page Page number
         * @param {number} [perPage] Page size
         * @param {string} [filter] Text filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet(user: string, page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonRolesPageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet(user, page, perPage, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns every group that belongs to the authenticated identity. The `{user}` parameter is kept for compatibility and is ignored.
         * @summary List authenticated user\'s groups
         * @param {string} user Compatibility placeholder (use \&#39;me\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1ProfileMyGroupsUserGet(user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DunaAuthCommonGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1ProfileMyGroupsUserGet(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.authlanceIdentityApiV1ProfileMyGroupsUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * Updates the authenticated user\'s profile. JSON payloads update the basic attributes and multipart bodies may include an avatar upload.
         * @summary Update current profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileMePost(options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1ProfileMePost(options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies if a group slug is free before the authenticated user attempts to create or join it.
         * @summary Check if a group name is available
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet(group: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupAvailabilityResponse> {
            return localVarFp.authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet(group, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns paginated platform roles that the authenticated user can request within their groups.
         * @summary List available roles for current context
         * @param {string} user User identity
         * @param {number} page Page number
         * @param {number} [perPage] Page size
         * @param {string} [filter] Text filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet(user: string, page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonRolesPageResponse> {
            return localVarFp.authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet(user, page, perPage, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns every group that belongs to the authenticated identity. The `{user}` parameter is kept for compatibility and is ignored.
         * @summary List authenticated user\'s groups
         * @param {string} user Compatibility placeholder (use \&#39;me\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileMyGroupsUserGet(user: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonGroup>> {
            return localVarFp.authlanceIdentityApiV1ProfileMyGroupsUserGet(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - interface
 * @export
 * @interface ProfileApi
 */
export interface ProfileApiInterface {
    /**
     * Updates the authenticated user\'s profile. JSON payloads update the basic attributes and multipart bodies may include an avatar upload.
     * @summary Update current profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApiInterface
     */
    authlanceIdentityApiV1ProfileMePost(options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Verifies if a group slug is free before the authenticated user attempts to create or join it.
     * @summary Check if a group name is available
     * @param {string} group Group name
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApiInterface
     */
    authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet(group: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupAvailabilityResponse>;

    /**
     * Returns paginated platform roles that the authenticated user can request within their groups.
     * @summary List available roles for current context
     * @param {string} user User identity
     * @param {number} page Page number
     * @param {number} [perPage] Page size
     * @param {string} [filter] Text filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApiInterface
     */
    authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet(user: string, page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonRolesPageResponse>;

    /**
     * Returns every group that belongs to the authenticated identity. The `{user}` parameter is kept for compatibility and is ignored.
     * @summary List authenticated user\'s groups
     * @param {string} user Compatibility placeholder (use \&#39;me\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApiInterface
     */
    authlanceIdentityApiV1ProfileMyGroupsUserGet(user: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonGroup>>;

}

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI implements ProfileApiInterface {
    /**
     * Updates the authenticated user\'s profile. JSON payloads update the basic attributes and multipart bodies may include an avatar upload.
     * @summary Update current profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public authlanceIdentityApiV1ProfileMePost(options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).authlanceIdentityApiV1ProfileMePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies if a group slug is free before the authenticated user attempts to create or join it.
     * @summary Check if a group name is available
     * @param {string} group Group name
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet(group: string, user: string, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).authlanceIdentityApiV1ProfileMyGroupGroupUserAvailableGet(group, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns paginated platform roles that the authenticated user can request within their groups.
     * @summary List available roles for current context
     * @param {string} user User identity
     * @param {number} page Page number
     * @param {number} [perPage] Page size
     * @param {string} [filter] Text filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet(user: string, page: number, perPage?: number, filter?: string, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).authlanceIdentityApiV1ProfileMyGroupRolesUserPageGet(user, page, perPage, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns every group that belongs to the authenticated identity. The `{user}` parameter is kept for compatibility and is ignored.
     * @summary List authenticated user\'s groups
     * @param {string} user Compatibility placeholder (use \&#39;me\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public authlanceIdentityApiV1ProfileMyGroupsUserGet(user: string, options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).authlanceIdentityApiV1ProfileMyGroupsUserGet(user, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RealmAdminGroupsApi - axios parameter creator
 * @export
 */
export const RealmAdminGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Realm-level admin endpoint to remove a user from the target group.
         * @summary Remove user from group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/realm/admin/group/{group}/members`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Realm-level admin endpoint to add or invite a user to the target group.
         * @summary Add user to group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupGroupMembersPost: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupGroupMembersPost', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/realm/admin/group/{group}/members`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Realm-level admin endpoint to manage roles assigned to a group member.
         * @summary Assign roles to group member (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupGroupRolePost: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupGroupRolePost', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/realm/admin/group/{group}/role`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Realm-level admin endpoint that returns the roles granted to the specified user inside the given group.
         * @summary Get a member\'s roles in a group (realm admin)
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet: async (group: string, user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet', 'group', group)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet', 'user', user)
            const localVarPath = `/authlance/identity/api/v1/realm/admin/group/{group}/role/{user}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Realm-level admin endpoint that lists every member in the group with their roles.
         * @summary List roles assigned within a group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupRolesGroupGet: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupRolesGroupGet', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/realm/admin/group/roles/{group}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RealmAdminGroupsApi - functional programming interface
 * @export
 */
export const RealmAdminGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RealmAdminGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Realm-level admin endpoint to remove a user from the target group.
         * @summary Remove user from group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmAdminGroupsApi.authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Realm-level admin endpoint to add or invite a user to the target group.
         * @summary Add user to group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmAdminGroupGroupMembersPost(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmAdminGroupGroupMembersPost(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmAdminGroupsApi.authlanceIdentityApiV1RealmAdminGroupGroupMembersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Realm-level admin endpoint to manage roles assigned to a group member.
         * @summary Assign roles to group member (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmAdminGroupGroupRolePost(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmAdminGroupGroupRolePost(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmAdminGroupsApi.authlanceIdentityApiV1RealmAdminGroupGroupRolePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Realm-level admin endpoint that returns the roles granted to the specified user inside the given group.
         * @summary Get a member\'s roles in a group (realm admin)
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupMemberRolesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet(group, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmAdminGroupsApi.authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Realm-level admin endpoint that lists every member in the group with their roles.
         * @summary List roles assigned within a group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmAdminGroupRolesGroupGet(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupMembershipRolesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmAdminGroupRolesGroupGet(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmAdminGroupsApi.authlanceIdentityApiV1RealmAdminGroupRolesGroupGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RealmAdminGroupsApi - factory interface
 * @export
 */
export const RealmAdminGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RealmAdminGroupsApiFp(configuration)
    return {
        /**
         * Realm-level admin endpoint to remove a user from the target group.
         * @summary Remove user from group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Realm-level admin endpoint to add or invite a user to the target group.
         * @summary Add user to group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupGroupMembersPost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1RealmAdminGroupGroupMembersPost(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Realm-level admin endpoint to manage roles assigned to a group member.
         * @summary Assign roles to group member (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupGroupRolePost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser> {
            return localVarFp.authlanceIdentityApiV1RealmAdminGroupGroupRolePost(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Realm-level admin endpoint that returns the roles granted to the specified user inside the given group.
         * @summary Get a member\'s roles in a group (realm admin)
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMemberRolesResponse> {
            return localVarFp.authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet(group, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Realm-level admin endpoint that lists every member in the group with their roles.
         * @summary List roles assigned within a group (realm admin)
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupRolesGroupGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMembershipRolesListResponse> {
            return localVarFp.authlanceIdentityApiV1RealmAdminGroupRolesGroupGet(group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RealmAdminGroupsApi - interface
 * @export
 * @interface RealmAdminGroupsApi
 */
export interface RealmAdminGroupsApiInterface {
    /**
     * Realm-level admin endpoint to remove a user from the target group.
     * @summary Remove user from group (realm admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApiInterface
     */
    authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Realm-level admin endpoint to add or invite a user to the target group.
     * @summary Add user to group (realm admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApiInterface
     */
    authlanceIdentityApiV1RealmAdminGroupGroupMembersPost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Realm-level admin endpoint to manage roles assigned to a group member.
     * @summary Assign roles to group member (realm admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApiInterface
     */
    authlanceIdentityApiV1RealmAdminGroupGroupRolePost(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonUser>;

    /**
     * Realm-level admin endpoint that returns the roles granted to the specified user inside the given group.
     * @summary Get a member\'s roles in a group (realm admin)
     * @param {string} group Group name
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApiInterface
     */
    authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMemberRolesResponse>;

    /**
     * Realm-level admin endpoint that lists every member in the group with their roles.
     * @summary List roles assigned within a group (realm admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApiInterface
     */
    authlanceIdentityApiV1RealmAdminGroupRolesGroupGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMembershipRolesListResponse>;

}

/**
 * RealmAdminGroupsApi - object-oriented interface
 * @export
 * @class RealmAdminGroupsApi
 * @extends {BaseAPI}
 */
export class RealmAdminGroupsApi extends BaseAPI implements RealmAdminGroupsApiInterface {
    /**
     * Realm-level admin endpoint to remove a user from the target group.
     * @summary Remove user from group (realm admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApi
     */
    public authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete(group: string, options?: RawAxiosRequestConfig) {
        return RealmAdminGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmAdminGroupGroupMembersDelete(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Realm-level admin endpoint to add or invite a user to the target group.
     * @summary Add user to group (realm admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApi
     */
    public authlanceIdentityApiV1RealmAdminGroupGroupMembersPost(group: string, options?: RawAxiosRequestConfig) {
        return RealmAdminGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmAdminGroupGroupMembersPost(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Realm-level admin endpoint to manage roles assigned to a group member.
     * @summary Assign roles to group member (realm admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApi
     */
    public authlanceIdentityApiV1RealmAdminGroupGroupRolePost(group: string, options?: RawAxiosRequestConfig) {
        return RealmAdminGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmAdminGroupGroupRolePost(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Realm-level admin endpoint that returns the roles granted to the specified user inside the given group.
     * @summary Get a member\'s roles in a group (realm admin)
     * @param {string} group Group name
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApi
     */
    public authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig) {
        return RealmAdminGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmAdminGroupGroupRoleUserGet(group, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Realm-level admin endpoint that lists every member in the group with their roles.
     * @summary List roles assigned within a group (realm admin)
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmAdminGroupsApi
     */
    public authlanceIdentityApiV1RealmAdminGroupRolesGroupGet(group: string, options?: RawAxiosRequestConfig) {
        return RealmAdminGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmAdminGroupRolesGroupGet(group, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RealmGroupsApi - axios parameter creator
 * @export
 */
export const RealmGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns public details for the specified group within the caller\'s realm.
         * @summary Get group
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupGroupGet: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupGroupGet', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/realm/group/{group}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the users that belong to the given group inside the caller\'s realm.
         * @summary List group members
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupGroupMembersGet: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupGroupMembersGet', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/realm/group/{group}/members`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates group metadata that is accessible within the current realm.
         * @summary Update group
         * @param {string} group Group name
         * @param {DunaAuthCommonGroup} payload Group data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupGroupPost: async (group: string, payload: DunaAuthCommonGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupGroupPost', 'group', group)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupGroupPost', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/realm/group/{group}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the roles granted to the specified user inside the given group within the caller\'s realm.
         * @summary Get a member\'s roles in a group
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupGroupRoleUserGet: async (group: string, user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupGroupRoleUserGet', 'group', group)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupGroupRoleUserGet', 'user', user)
            const localVarPath = `/authlance/identity/api/v1/realm/group/{group}/role/{user}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RealmGroupsApi - functional programming interface
 * @export
 */
export const RealmGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RealmGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns public details for the specified group within the caller\'s realm.
         * @summary Get group
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupGroupGet(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupGroupGet(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmGroupsApi.authlanceIdentityApiV1RealmGroupGroupGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists the users that belong to the given group inside the caller\'s realm.
         * @summary List group members
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupGroupMembersGet(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DunaAuthCommonUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupGroupMembersGet(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmGroupsApi.authlanceIdentityApiV1RealmGroupGroupMembersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates group metadata that is accessible within the current realm.
         * @summary Update group
         * @param {string} group Group name
         * @param {DunaAuthCommonGroup} payload Group data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupGroupPost(group: string, payload: DunaAuthCommonGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupGroupPost(group, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmGroupsApi.authlanceIdentityApiV1RealmGroupGroupPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the roles granted to the specified user inside the given group within the caller\'s realm.
         * @summary Get a member\'s roles in a group
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupMemberRolesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupGroupRoleUserGet(group, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealmGroupsApi.authlanceIdentityApiV1RealmGroupGroupRoleUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RealmGroupsApi - factory interface
 * @export
 */
export const RealmGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RealmGroupsApiFp(configuration)
    return {
        /**
         * Returns public details for the specified group within the caller\'s realm.
         * @summary Get group
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupGroupGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup> {
            return localVarFp.authlanceIdentityApiV1RealmGroupGroupGet(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the users that belong to the given group inside the caller\'s realm.
         * @summary List group members
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupGroupMembersGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonUser>> {
            return localVarFp.authlanceIdentityApiV1RealmGroupGroupMembersGet(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates group metadata that is accessible within the current realm.
         * @summary Update group
         * @param {string} group Group name
         * @param {DunaAuthCommonGroup} payload Group data to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupGroupPost(group: string, payload: DunaAuthCommonGroup, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup> {
            return localVarFp.authlanceIdentityApiV1RealmGroupGroupPost(group, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the roles granted to the specified user inside the given group within the caller\'s realm.
         * @summary Get a member\'s roles in a group
         * @param {string} group Group name
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMemberRolesResponse> {
            return localVarFp.authlanceIdentityApiV1RealmGroupGroupRoleUserGet(group, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RealmGroupsApi - interface
 * @export
 * @interface RealmGroupsApi
 */
export interface RealmGroupsApiInterface {
    /**
     * Returns public details for the specified group within the caller\'s realm.
     * @summary Get group
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmGroupsApiInterface
     */
    authlanceIdentityApiV1RealmGroupGroupGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup>;

    /**
     * Lists the users that belong to the given group inside the caller\'s realm.
     * @summary List group members
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmGroupsApiInterface
     */
    authlanceIdentityApiV1RealmGroupGroupMembersGet(group: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonUser>>;

    /**
     * Updates group metadata that is accessible within the current realm.
     * @summary Update group
     * @param {string} group Group name
     * @param {DunaAuthCommonGroup} payload Group data to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmGroupsApiInterface
     */
    authlanceIdentityApiV1RealmGroupGroupPost(group: string, payload: DunaAuthCommonGroup, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroup>;

    /**
     * Returns the roles granted to the specified user inside the given group within the caller\'s realm.
     * @summary Get a member\'s roles in a group
     * @param {string} group Group name
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmGroupsApiInterface
     */
    authlanceIdentityApiV1RealmGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupMemberRolesResponse>;

}

/**
 * RealmGroupsApi - object-oriented interface
 * @export
 * @class RealmGroupsApi
 * @extends {BaseAPI}
 */
export class RealmGroupsApi extends BaseAPI implements RealmGroupsApiInterface {
    /**
     * Returns public details for the specified group within the caller\'s realm.
     * @summary Get group
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmGroupsApi
     */
    public authlanceIdentityApiV1RealmGroupGroupGet(group: string, options?: RawAxiosRequestConfig) {
        return RealmGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmGroupGroupGet(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the users that belong to the given group inside the caller\'s realm.
     * @summary List group members
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmGroupsApi
     */
    public authlanceIdentityApiV1RealmGroupGroupMembersGet(group: string, options?: RawAxiosRequestConfig) {
        return RealmGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmGroupGroupMembersGet(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates group metadata that is accessible within the current realm.
     * @summary Update group
     * @param {string} group Group name
     * @param {DunaAuthCommonGroup} payload Group data to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmGroupsApi
     */
    public authlanceIdentityApiV1RealmGroupGroupPost(group: string, payload: DunaAuthCommonGroup, options?: RawAxiosRequestConfig) {
        return RealmGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmGroupGroupPost(group, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the roles granted to the specified user inside the given group within the caller\'s realm.
     * @summary Get a member\'s roles in a group
     * @param {string} group Group name
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealmGroupsApi
     */
    public authlanceIdentityApiV1RealmGroupGroupRoleUserGet(group: string, user: string, options?: RawAxiosRequestConfig) {
        return RealmGroupsApiFp(this.configuration).authlanceIdentityApiV1RealmGroupGroupRoleUserGet(group, user, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SecretsApi - axios parameter creator
 * @export
 */
export const SecretsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes all encrypted secrets for a group (admin only)
         * @summary Delete group secrets
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsDelete: async (groupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsDelete', 'groupId', groupId)
            const localVarPath = `/authlance/identity/api/v1/realm/admin/groups/{groupId}/secrets`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the group key and secrets (admin only). Warning: This permanently deletes all encrypted data.
         * @summary Reset group secrets
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsResetPost: async (groupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsResetPost', 'groupId', groupId)
            const localVarPath = `/authlance/identity/api/v1/realm/admin/groups/{groupId}/secrets/reset`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the encrypted secrets payload for a group
         * @summary Get group secrets
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdSecretsGet: async (groupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdSecretsGet', 'groupId', groupId)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/secrets`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if the group key has been initialized
         * @summary Get key status
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdSecretsKeyStatusGet: async (groupId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdSecretsKeyStatusGet', 'groupId', groupId)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/secrets/key-status`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initializes the encrypted secrets for a group (first device only)
         * @summary Initialize group secrets
         * @param {number} groupId Group ID
         * @param {ControllersDevicesInitializeSecretsRequest} payload Secrets payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdSecretsPost: async (groupId: number, payload: ControllersDevicesInitializeSecretsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdSecretsPost', 'groupId', groupId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdSecretsPost', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/secrets`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the encrypted secrets payload for a group
         * @summary Update group secrets
         * @param {number} groupId Group ID
         * @param {ControllersDevicesUpdateSecretsRequest} payload Updated secrets payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdSecretsPut: async (groupId: number, payload: ControllersDevicesUpdateSecretsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdSecretsPut', 'groupId', groupId)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1RealmGroupsGroupIdSecretsPut', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/realm/groups/{groupId}/secrets`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecretsApi - functional programming interface
 * @export
 */
export const SecretsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecretsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes all encrypted secrets for a group (admin only)
         * @summary Delete group secrets
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsDelete(groupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsDelete(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resets the group key and secrets (admin only). Warning: This permanently deletes all encrypted data.
         * @summary Reset group secrets
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsResetPost(groupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsResetPost(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsResetPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the encrypted secrets payload for a group
         * @summary Get group secrets
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdSecretsGet(groupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersDevicesSecretsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdSecretsGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.authlanceIdentityApiV1RealmGroupsGroupIdSecretsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks if the group key has been initialized
         * @summary Get key status
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdSecretsKeyStatusGet(groupId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersDevicesKeyStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdSecretsKeyStatusGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.authlanceIdentityApiV1RealmGroupsGroupIdSecretsKeyStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initializes the encrypted secrets for a group (first device only)
         * @summary Initialize group secrets
         * @param {number} groupId Group ID
         * @param {ControllersDevicesInitializeSecretsRequest} payload Secrets payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdSecretsPost(groupId: number, payload: ControllersDevicesInitializeSecretsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersDevicesSecretsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdSecretsPost(groupId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.authlanceIdentityApiV1RealmGroupsGroupIdSecretsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the encrypted secrets payload for a group
         * @summary Update group secrets
         * @param {number} groupId Group ID
         * @param {ControllersDevicesUpdateSecretsRequest} payload Updated secrets payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1RealmGroupsGroupIdSecretsPut(groupId: number, payload: ControllersDevicesUpdateSecretsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersDevicesSecretsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1RealmGroupsGroupIdSecretsPut(groupId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.authlanceIdentityApiV1RealmGroupsGroupIdSecretsPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SecretsApi - factory interface
 * @export
 */
export const SecretsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecretsApiFp(configuration)
    return {
        /**
         * Deletes all encrypted secrets for a group (admin only)
         * @summary Delete group secrets
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsDelete(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsDelete(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the group key and secrets (admin only). Warning: This permanently deletes all encrypted data.
         * @summary Reset group secrets
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsResetPost(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsResetPost(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the encrypted secrets payload for a group
         * @summary Get group secrets
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdSecretsGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesSecretsResponse> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdSecretsGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if the group key has been initialized
         * @summary Get key status
         * @param {number} groupId Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdSecretsKeyStatusGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesKeyStatusResponse> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdSecretsKeyStatusGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Initializes the encrypted secrets for a group (first device only)
         * @summary Initialize group secrets
         * @param {number} groupId Group ID
         * @param {ControllersDevicesInitializeSecretsRequest} payload Secrets payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdSecretsPost(groupId: number, payload: ControllersDevicesInitializeSecretsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesSecretsResponse> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdSecretsPost(groupId, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the encrypted secrets payload for a group
         * @summary Update group secrets
         * @param {number} groupId Group ID
         * @param {ControllersDevicesUpdateSecretsRequest} payload Updated secrets payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1RealmGroupsGroupIdSecretsPut(groupId: number, payload: ControllersDevicesUpdateSecretsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesSecretsResponse> {
            return localVarFp.authlanceIdentityApiV1RealmGroupsGroupIdSecretsPut(groupId, payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecretsApi - interface
 * @export
 * @interface SecretsApi
 */
export interface SecretsApiInterface {
    /**
     * Deletes all encrypted secrets for a group (admin only)
     * @summary Delete group secrets
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApiInterface
     */
    authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsDelete(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Resets the group key and secrets (admin only). Warning: This permanently deletes all encrypted data.
     * @summary Reset group secrets
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApiInterface
     */
    authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsResetPost(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Gets the encrypted secrets payload for a group
     * @summary Get group secrets
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdSecretsGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesSecretsResponse>;

    /**
     * Checks if the group key has been initialized
     * @summary Get key status
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdSecretsKeyStatusGet(groupId: number, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesKeyStatusResponse>;

    /**
     * Initializes the encrypted secrets for a group (first device only)
     * @summary Initialize group secrets
     * @param {number} groupId Group ID
     * @param {ControllersDevicesInitializeSecretsRequest} payload Secrets payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdSecretsPost(groupId: number, payload: ControllersDevicesInitializeSecretsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesSecretsResponse>;

    /**
     * Updates the encrypted secrets payload for a group
     * @summary Update group secrets
     * @param {number} groupId Group ID
     * @param {ControllersDevicesUpdateSecretsRequest} payload Updated secrets payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApiInterface
     */
    authlanceIdentityApiV1RealmGroupsGroupIdSecretsPut(groupId: number, payload: ControllersDevicesUpdateSecretsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersDevicesSecretsResponse>;

}

/**
 * SecretsApi - object-oriented interface
 * @export
 * @class SecretsApi
 * @extends {BaseAPI}
 */
export class SecretsApi extends BaseAPI implements SecretsApiInterface {
    /**
     * Deletes all encrypted secrets for a group (admin only)
     * @summary Delete group secrets
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsDelete(groupId: number, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsDelete(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the group key and secrets (admin only). Warning: This permanently deletes all encrypted data.
     * @summary Reset group secrets
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsResetPost(groupId: number, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).authlanceIdentityApiV1RealmAdminGroupsGroupIdSecretsResetPost(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the encrypted secrets payload for a group
     * @summary Get group secrets
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdSecretsGet(groupId: number, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdSecretsGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if the group key has been initialized
     * @summary Get key status
     * @param {number} groupId Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdSecretsKeyStatusGet(groupId: number, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdSecretsKeyStatusGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initializes the encrypted secrets for a group (first device only)
     * @summary Initialize group secrets
     * @param {number} groupId Group ID
     * @param {ControllersDevicesInitializeSecretsRequest} payload Secrets payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdSecretsPost(groupId: number, payload: ControllersDevicesInitializeSecretsRequest, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdSecretsPost(groupId, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the encrypted secrets payload for a group
     * @summary Update group secrets
     * @param {number} groupId Group ID
     * @param {ControllersDevicesUpdateSecretsRequest} payload Updated secrets payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public authlanceIdentityApiV1RealmGroupsGroupIdSecretsPut(groupId: number, payload: ControllersDevicesUpdateSecretsRequest, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).authlanceIdentityApiV1RealmGroupsGroupIdSecretsPut(groupId, payload, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Verifies a StoreKit transaction and records the group subscription.
         * @summary Verify App Store subscription
         * @param {string} user User identity
         * @param {ControllersSubscriptionsAppStoreVerifyRequest} payload App Store verification payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileSubscriptionsUserAppStoreVerifyPost: async (user: string, payload: ControllersSubscriptionsAppStoreVerifyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileSubscriptionsUserAppStoreVerifyPost', 'user', user)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileSubscriptionsUserAppStoreVerifyPost', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/profile/subscriptions/{user}/app-store/verify`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Looks up a group subscription using the external billing subscription ID.
         * @summary Get subscription by billing subscription ID
         * @param {string} user User identity
         * @param {string} billingSubscriptionID Billing subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet: async (user: string, billingSubscriptionID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet', 'user', user)
            // verify required parameter 'billingSubscriptionID' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet', 'billingSubscriptionID', billingSubscriptionID)
            const localVarPath = `/authlance/identity/api/v1/profile/subscriptions/{user}/billing/{billingSubscriptionID}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"billingSubscriptionID"}}`, encodeURIComponent(String(billingSubscriptionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the active subscription for a group. If no active subscription, returns the most recent.
         * @summary Get active or latest subscription for group
         * @param {string} user User identity
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet: async (user: string, group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet', 'user', user)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet', 'group', group)
            const localVarPath = `/authlance/identity/api/v1/profile/subscriptions/{user}/{group}/active`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all available payment tiers.
         * @summary List subscription tiers
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet: async (user: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet', 'user', user)
            const localVarPath = `/authlance/identity/api/v1/profile/subscriptions/{user}/tiers`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Processes App Store Server Notifications v2 payloads.
         * @summary Handle App Store Server Notifications
         * @param {ControllersSubscriptionsAppStoreServerNotificationRequest} payload Server notification payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1SubscriptionsAppStoreNotificationsPost: async (payload: ControllersSubscriptionsAppStoreServerNotificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('authlanceIdentityApiV1SubscriptionsAppStoreNotificationsPost', 'payload', payload)
            const localVarPath = `/authlance/identity/api/v1/subscriptions/app-store/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all available payment tiers. No authentication required.
         * @summary List subscription tiers (public)
         * @param {string} [platform] Filter by platform (ios, android, web)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1SubscriptionsTiersGet: async (platform?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authlance/identity/api/v1/subscriptions/tiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Verifies a StoreKit transaction and records the group subscription.
         * @summary Verify App Store subscription
         * @param {string} user User identity
         * @param {ControllersSubscriptionsAppStoreVerifyRequest} payload App Store verification payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1ProfileSubscriptionsUserAppStoreVerifyPost(user: string, payload: ControllersSubscriptionsAppStoreVerifyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllersSubscriptionsAppStoreVerifyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1ProfileSubscriptionsUserAppStoreVerifyPost(user, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.authlanceIdentityApiV1ProfileSubscriptionsUserAppStoreVerifyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Looks up a group subscription using the external billing subscription ID.
         * @summary Get subscription by billing subscription ID
         * @param {string} user User identity
         * @param {string} billingSubscriptionID Billing subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet(user: string, billingSubscriptionID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupSubscriptionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet(user, billingSubscriptionID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the active subscription for a group. If no active subscription, returns the most recent.
         * @summary Get active or latest subscription for group
         * @param {string} user User identity
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet(user: string, group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DunaAuthCommonGroupSubscriptionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet(user, group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all available payment tiers.
         * @summary List subscription tiers
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet(user: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DunaAuthCommonPaymentTierDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Processes App Store Server Notifications v2 payloads.
         * @summary Handle App Store Server Notifications
         * @param {ControllersSubscriptionsAppStoreServerNotificationRequest} payload Server notification payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1SubscriptionsAppStoreNotificationsPost(payload: ControllersSubscriptionsAppStoreServerNotificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1SubscriptionsAppStoreNotificationsPost(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.authlanceIdentityApiV1SubscriptionsAppStoreNotificationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all available payment tiers. No authentication required.
         * @summary List subscription tiers (public)
         * @param {string} [platform] Filter by platform (ios, android, web)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authlanceIdentityApiV1SubscriptionsTiersGet(platform?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DunaAuthCommonPaymentTierDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authlanceIdentityApiV1SubscriptionsTiersGet(platform, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.authlanceIdentityApiV1SubscriptionsTiersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * Verifies a StoreKit transaction and records the group subscription.
         * @summary Verify App Store subscription
         * @param {string} user User identity
         * @param {ControllersSubscriptionsAppStoreVerifyRequest} payload App Store verification payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileSubscriptionsUserAppStoreVerifyPost(user: string, payload: ControllersSubscriptionsAppStoreVerifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersSubscriptionsAppStoreVerifyResponse> {
            return localVarFp.authlanceIdentityApiV1ProfileSubscriptionsUserAppStoreVerifyPost(user, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Looks up a group subscription using the external billing subscription ID.
         * @summary Get subscription by billing subscription ID
         * @param {string} user User identity
         * @param {string} billingSubscriptionID Billing subscription ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet(user: string, billingSubscriptionID: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupSubscriptionsDto> {
            return localVarFp.authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet(user, billingSubscriptionID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the active subscription for a group. If no active subscription, returns the most recent.
         * @summary Get active or latest subscription for group
         * @param {string} user User identity
         * @param {string} group Group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet(user: string, group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupSubscriptionsDto> {
            return localVarFp.authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet(user, group, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all available payment tiers.
         * @summary List subscription tiers
         * @param {string} user User identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet(user: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonPaymentTierDto>> {
            return localVarFp.authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Processes App Store Server Notifications v2 payloads.
         * @summary Handle App Store Server Notifications
         * @param {ControllersSubscriptionsAppStoreServerNotificationRequest} payload Server notification payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1SubscriptionsAppStoreNotificationsPost(payload: ControllersSubscriptionsAppStoreServerNotificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.authlanceIdentityApiV1SubscriptionsAppStoreNotificationsPost(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all available payment tiers. No authentication required.
         * @summary List subscription tiers (public)
         * @param {string} [platform] Filter by platform (ios, android, web)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authlanceIdentityApiV1SubscriptionsTiersGet(platform?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonPaymentTierDto>> {
            return localVarFp.authlanceIdentityApiV1SubscriptionsTiersGet(platform, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionsApi - interface
 * @export
 * @interface SubscriptionsApi
 */
export interface SubscriptionsApiInterface {
    /**
     * Verifies a StoreKit transaction and records the group subscription.
     * @summary Verify App Store subscription
     * @param {string} user User identity
     * @param {ControllersSubscriptionsAppStoreVerifyRequest} payload App Store verification payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    authlanceIdentityApiV1ProfileSubscriptionsUserAppStoreVerifyPost(user: string, payload: ControllersSubscriptionsAppStoreVerifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControllersSubscriptionsAppStoreVerifyResponse>;

    /**
     * Looks up a group subscription using the external billing subscription ID.
     * @summary Get subscription by billing subscription ID
     * @param {string} user User identity
     * @param {string} billingSubscriptionID Billing subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet(user: string, billingSubscriptionID: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupSubscriptionsDto>;

    /**
     * Returns the active subscription for a group. If no active subscription, returns the most recent.
     * @summary Get active or latest subscription for group
     * @param {string} user User identity
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet(user: string, group: string, options?: RawAxiosRequestConfig): AxiosPromise<DunaAuthCommonGroupSubscriptionsDto>;

    /**
     * Returns all available payment tiers.
     * @summary List subscription tiers
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet(user: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonPaymentTierDto>>;

    /**
     * Processes App Store Server Notifications v2 payloads.
     * @summary Handle App Store Server Notifications
     * @param {ControllersSubscriptionsAppStoreServerNotificationRequest} payload Server notification payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    authlanceIdentityApiV1SubscriptionsAppStoreNotificationsPost(payload: ControllersSubscriptionsAppStoreServerNotificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }>;

    /**
     * Returns all available payment tiers. No authentication required.
     * @summary List subscription tiers (public)
     * @param {string} [platform] Filter by platform (ios, android, web)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApiInterface
     */
    authlanceIdentityApiV1SubscriptionsTiersGet(platform?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DunaAuthCommonPaymentTierDto>>;

}

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI implements SubscriptionsApiInterface {
    /**
     * Verifies a StoreKit transaction and records the group subscription.
     * @summary Verify App Store subscription
     * @param {string} user User identity
     * @param {ControllersSubscriptionsAppStoreVerifyRequest} payload App Store verification payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public authlanceIdentityApiV1ProfileSubscriptionsUserAppStoreVerifyPost(user: string, payload: ControllersSubscriptionsAppStoreVerifyRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).authlanceIdentityApiV1ProfileSubscriptionsUserAppStoreVerifyPost(user, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Looks up a group subscription using the external billing subscription ID.
     * @summary Get subscription by billing subscription ID
     * @param {string} user User identity
     * @param {string} billingSubscriptionID Billing subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet(user: string, billingSubscriptionID: string, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).authlanceIdentityApiV1ProfileSubscriptionsUserBillingBillingSubscriptionIDGet(user, billingSubscriptionID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the active subscription for a group. If no active subscription, returns the most recent.
     * @summary Get active or latest subscription for group
     * @param {string} user User identity
     * @param {string} group Group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet(user: string, group: string, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).authlanceIdentityApiV1ProfileSubscriptionsUserGroupActiveGet(user, group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all available payment tiers.
     * @summary List subscription tiers
     * @param {string} user User identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet(user: string, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).authlanceIdentityApiV1ProfileSubscriptionsUserTiersGet(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Processes App Store Server Notifications v2 payloads.
     * @summary Handle App Store Server Notifications
     * @param {ControllersSubscriptionsAppStoreServerNotificationRequest} payload Server notification payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public authlanceIdentityApiV1SubscriptionsAppStoreNotificationsPost(payload: ControllersSubscriptionsAppStoreServerNotificationRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).authlanceIdentityApiV1SubscriptionsAppStoreNotificationsPost(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all available payment tiers. No authentication required.
     * @summary List subscription tiers (public)
     * @param {string} [platform] Filter by platform (ios, android, web)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public authlanceIdentityApiV1SubscriptionsTiersGet(platform?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).authlanceIdentityApiV1SubscriptionsTiersGet(platform, options).then((request) => request(this.axios, this.basePath));
    }
}



